{"./":{"url":"./","title":"Sudal's Note","keywords":"","body":"# "},"book/introduce.html":{"url":"book/introduce.html","title":"Introduction","keywords":"","body":"Introduce 하루중 매 순간 잊어버리고 잃어버리기 일쑤다.모른다고 죄가 사면되지 않기 때문에 순간 아는것 만으로도 최대한 지키려고 노력해야 한다 인생은 늘 억울하고 불공평 하기 때문에 옳은것만 선택하며 살아갈 힘 을 길러야 한다. 누구나 올라갈 수 있는 한계가 있기 마련이다. 내가 갈 수있는 한계에 올라섰을때 그 자리가 비록 남들보다 낮아도 그 자리에서 만족할 수 있어야 한다. 목표를 크게 잡아 실패하는건 문제가 아니다.목표를 낮게 잡아 이루는것이 큰 문제이다.-미켈란젤로- 당신은 당신이 반복한 행동의 결과이다.모든것은 습관에 달려있다.-아리스토텔레스 자존심은 어리석음의 고통을 줄여주는 마취제와 같다. 자만은 어리석은 사람들의 필요없는 짐과 같다. 그정도면 괜찮아는 괜찮은게 아니다.더 좋을수 있었다면 좋은게 아니다. "},"book/manual.html":{"url":"book/manual.html","title":"Manual","keywords":"","body":"Manual 이 Gitbook 의 사용법과 Syntax 를 정의한다. CLI (Command Line Interface) # Build (빌드에 필요한 라이브러리, 플러그인 등을 설치) $ gitbook install # Local Server (로컬 환경에서 확인) $ gitbook serve # Remote Static Publish (`gh-pages` 브랜치에 푸시하기 위한 빌드 스크립트) ./publish_gitbook.sh Tip 맥 백쿼트(`) 만들기 $ if ! [ -f ~/Library/KeyBindings/DefaultkeyBinding.dict ]; then mkdir -p ~/Library/KeyBindings && echo '{\"₩\" = (\"insertText:\", \"\\`\");}' > ~/Library/KeyBindings/DefaultkeyBinding.dict; fi 바로 적용이 안된다면 재부팅 한다. VSCode 마크다운 설정 수정 \"markdownlint.config\": { \"MD001\": false, // 순차적 헤더 \"MD024\": false, // 중복 헤더 제목 \"MD026\": false // 헤더에 특수문자 } 다이어그램 (mermaid) graph TD; A-->B; A-->C; B-->D; C-->D; sequenceDiagram participant Alice participant Bob Alice->John: Hello John, how are you? loop Healthcheck John->John: Fight against hypochondria end Note right of John: Rational thoughts prevail... John-->Alice: Great! John->Bob: How about you? Bob-->John: Jolly good! gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d sequenceDiagram Alice ->> Bob: Hello Bob, how are you? Bob-->>John: How about you John? Bob--x Alice: I am good thanks! Bob-x John: I am good thanks! Note right of John: Bob thinks a longlong time, so longthat the text doesnot fit on a row. Bob-->Alice: Checking with John... Alice->John: Yes... John, how are you? graph LR A[Square Rect] -- Link text --> B((Circle)) A --> C(Round Rect) B --> D{Rhombus} C --> D graph TB sq[Square shape] --> ci((Circle shape)) subgraph A subgraph od>Odd shape]-- Two lineedge comment --> ro di{Diamond with line break} -.-> ro(Roundedsquareshape) di==>ro2(Rounded square shape) end %% Notice that no text in shape are added here instead that is appended further down e --> od3>Really long text with linebreakin an Odd shape] %% Comments after double percent signs e((Inner / circleand some odd special characters)) --> f(,.?!+-*ز) cyr[Cyrillic]-->cyr2((Circle shape Начало)); classDef green fill:#9f6,stroke:#333,stroke-width:2px; classDef orange fill:#f96,stroke:#333,stroke-width:4px; class sq,e green class di orange sequenceDiagram loop Daily query Alice->>Bob: Hello Bob, how are you? alt is sick Bob->>Alice: Not so good :( else is well Bob->>Alice: Feeling fresh like a daisy end opt Extra response Bob->>Alice: Thanks for asking end end sequenceDiagram participant Alice participant Bob Alice->>John: Hello John, how are you? loop Healthcheck John->>John: Fight against hypochondria end Note right of John: Rational thoughtsprevail... John-->>Alice: Great! John->>Bob: How about you? Bob-->>John: Jolly good! 참고자료 https://mermaidjs.github.io/ "},"book/template.html":{"url":"book/template.html","title":"Template","keywords":"","body":"Template 제목 이 페이지는 깃북의 작성 가이드 문서 입니다.아래 가이드대로 작성해주세요. 주제 구분 1 이것의 정의는 이렇다 한다. Description 이건 이것이고 저건 저것이다. Syntax public class Foo { public static void main (String[] args) { System.out.println(\"Hello World\"); } } Parameters Foo 클래스명 args 매개변수 Return 반환값 없음 내용 정리 이래이래해서 저래저래 한것이다. 주제 구분 2 이것의 정의는 아래와 같이 이렇다 한다. Example 아래는 위 사항에 대한 두가지 예시 이다. Case 1 (function (param) { console.log(param || 'Hello World'); }()); 위와 같이 이래저래 하면 결론은 아래와 같다. 결론결론은 결론이다. 그래서 그렇게 된것이다. Parameters param 파라메터 정보 Case 2 (function () { console.log('Hello World'); }()); 위의 결과는 ES5 로 작성된 코드이다. 이건 비밀인데 비밀인것이야 이는 다음과 같이 비교 가능하다. 항목과 값의 비교 항목 값 a 100 200 b 피자치킨 d c 자동차비행기 d bcef 1211 특정 경로 링크 를 통하여 이동가능하다. 참고자료 http://www.myungseok.github.iohttp://www.myungseok.github.io "},"book/01.-general/":{"url":"book/01.-general/","title":"01. General","keywords":"","body":"01. General IT 전반에 걸친 일반적인 지식들을 정리한다. 문 과 식 의 차이 문과 식은 비슷하지만 조금은 다른 차이점이 있다. 문 코드 엔진에서 해석하고 버리는 힌트 같은 것 대표 언어 : Java, Javascript, C 등등 식 변수에 할당되어 저장 된다 대표 언어 : Ruby, Kotlin 등등 메모리 공간 구조의 대해 프로그램 실행시 운영체제 는 우리가 실행시키는 프로그램을 위해 메모리 공간을 할당 해 준다.이는 크게 데이터 (Data), 힙 (Heap), 스택 (Stack) 로 나뉘게 되며 각각의 시기, 용도, 위치가 다르게 된다. 용도 생명주기 데이터 (Data) 전역변수와 static 변수가 할당되는 영역 프로그램의 시작과 동시에 할당되고프로그램이 종료되어야 메모리에서 소멸 힙 (Heap) 필요에 의해 동적으로 메모리를 할당 할 때 사용 (Runtime) - 스택 (Stack) 함수 호출시에 생성되는 지역변수와 매개변수가 저장되는 영역 (Compile) 함수 호출이 완료되면 사라짐 스택 (Stack) 과 힙 (heap) 을 좀더 세부적으로 비교해보면 다음과 같다. 스택 (Stack) 힙 (Heap) 접근 속도 빠른 접근 느린 접근 메모리 제한 제한적 제한 없음 Resize 가능 불가 (Compile 시에 결정) 가능 (파편화 가능성) 특징 지역변수에만 할당 전역적 접근 참고자료 http://dsnight.tistory.com/50 Unsinged Int 부호가 없는 정수형의 값만 가진다.때문에 부호를 결정짓는 비트만큼의 값의 범위가 늘어난다. 유형 바이트 이름 값의 범위 int 4 signed –2,147,483,648 ~ 2,147,483,647 unsigned int 4 unsigned 0 ~ 4,294,967,295 char 1 없음 –128~127(기본값)/J를 사용하여 컴파일된 경우 0~255 signed char 1 signed -128 ~ 127 unsigned char 1 unsigned 0 ~ 255 참고자료 https://msdn.microsoft.com/ko-kr/library/s3f49ktz.aspx 교착 상태 (Deadlock : 데드락) 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태를 말한다. 대개 멀티 프로그래밍 환경에서 한정된 자원을 서로 사용하려고 경쟁하는 상황에서 발생한다. 원인 한 시스템 내에서 아래 네가지 조건이 동시에 성립하면 발생 상호 배제 (Mutal Exclusion) 자원은 한 번에 한 프로세스만 사용할 수 있어야 한다. 점유 대기 (Hold and Wait) ??? 비선점 (No Preemption) 다른 프로세스에 할당된 자원은 사용이 끝날때까지 강제로 점유할 수 없다. 순환 대기 (Circular Wait) ??? 해결 교착 상태 예방 및 회피 교착 상태 탐지 및 회복 교착 상태 무시 예방 교착 상태의 회피 방법중에 은행원 알고리즘 (Banker's Algorithm) 이라고 있으며 다음과 같다. 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정된 상태로 남아있는지 사전에 검사하여 교착상태를 회피하는 기법 안정된 상태에 있으면 자원을 할당하며, 그렇지 않으면 다른 프로세스들이 자원을 해지할 때까지 대기한다. 참고자료 https://includestdio.tistory.com/12 Type-Safe 란? 어떠한 연산 (Operation) 도 정의 되지 않는 결과를 내놓지 않는 것 이라고 한다. 이는 예측 불가능한 결과를 내지 않는건데 예를 들면 1 + '1' 아래의 연산이 가능하거나 문자열 변수에 숫자 1을 할당하는 것이 가능하다거나 하는 비논리적인 일 을 일컫는다. 보통 type-safe 하다고 알려진 언어에서는 컴파일시에 이런 에러를 처리해주지만 type-safe 하지 않는 언어에서는 이를 적당이 암묵적으로 처리한다. 그래서 javascript 는 type-safe 한 언어가 아니라고 한다. 일반적으로 C#, java 등과 같이 컴파일 기반언어들을 type-safe 한 언어로 취급한다. 참고자료 https://m.blog.naver.com/PostView.nhn?blogId=jerrypop&logNo=40117130140&proxyReferer=https%3A%2F%2Fwww.google.com%2F "},"book/01.-general/architecture/":{"url":"book/01.-general/architecture/","title":"Architecture","keywords":"","body":"Architecture 설계 지향적 관점에서 관련된 것을 정리한다. RBAC (Role Based Access Control : 역활기반 접근 통제) 접근하려는 사용자와 자원이 어떻게 상호작용하는지 결정하여 중앙에서 집중적으로 작용한다. 역할 할당 (Role Assignment) 역할 권한 부여 (Role Authorization) 권한 부여 (Permission Authorization) MAC (Mandatory Access Control : 강제적 접근 통제) DAC (Discretionary Access Control : 임의적 접근 통제) Separation Of Concern (관심의 분리) SOA (Service-Oriented Architecture : 서비스 지향 아키텍처) 의 핵심 원칙중의 하나로 관심이 다른것은 가능한 분리하여 서로 영향을 주지 않도록 하며, 관심이 같은 것은 하나의 관련 객체로 모이도록 설계나 구현 을 하는 것 TDD / BDD / DDD 테스트 주도 개발 방법론들이다. TDD (Test Driven Development) 테스트 주도 개발 방법론 테스트 코드를 먼저 작성하고 해당 테스트 코드에 맞게 개발을 진행한다. BDD (Behavior Driven Development) 동작 지향 개발 방법론 소프트웨어의 품질을 향상 시키기 위해 개발자간의 협력 가능한 Agile Software Development 기법이다. BDD 의 목표는 TDD 를 수행하기 위한 것으로, TDD 를 수행하기 위해 BDD 를 통한 행위 자체를 변경 가능하다. "},"book/01.-general/architecture/msa.html":{"url":"book/01.-general/architecture/msa.html","title":"MSA","keywords":"","body":"Micro Service Architecture (MSA : 마이크로 서비스 아키텍처) "},"book/01.-general/data-structure/":{"url":"book/01.-general/data-structure/","title":"Data Structure","keywords":"","body":"Data Structure 자료를 효율적으로 이용할 수 있도록 컴퓨터에 저장하는 방법이다. graph LR A[\"자료형\"] --> B[\"단순 구조\"] B --> F[\"정수\"] B --> G[\"실수\"] B --> H[\"문자\"] B --> I[\"문자열\"] A[\"자료형\"] --> C[\"선형 구조\"] C --> J[\"순차 리스트\"] C --> K[\"연결 리스트\"] J --> O[\"단순 연결 리스트\"] J --> P[\"이중 연결 리스트\"] J --> Q[\"원형 연결 리스트\"] C --> L[\"스택\"] C --> M[\"큐\"] C --> N[\"덱\"] A[\"자료형\"] --> D[\"비선형 구조\"] D --> R[\"트리\"] R --> T[\"일반 트리\"] R --> U[\"이진 트리\"] D --> S[\"그래프\"] S --> V[\"방향 그래프\"] S --> W[\"무방향 그래프\"] A[\"자료형\"] --> E[\"파일 구조\"] E --> X[\"순차 파일\"] E --> Y[\"색인 파일\"] E --> Z[\"직접 파일\"] List 와 Map 의 비교 List 순차적으로 데이터를 저장한다. 값의 중복이 허용된다. 순차적인 접근이 필요할 경우 사용 Map 키를 중복으로 저장불가 하다. (값은 가능) 빈 공간을 찾아서 저장하기 때문에 List 보다는 데이터 저장속도가 느릴수 있다. 키값을 통해서 빠르게 데이터 검색 가능 "},"book/01.-general/data-structure/data-type.html":{"url":"book/01.-general/data-structure/data-type.html","title":"Data Type","keywords":"","body":"Data Type 논리형 true false 중 하나를 값으로 갖으며, 조건식과 논리적 계산에 사용 boolean : 1 Byte 문자형 문자를 저장하는데 사용되며 변수당 하나의 문자만 저장 가능 char : 2 Byte String 은 (byte[] bytes) 이다 정수형 정수값을 저장하는데 사용되며 주로 int long 을 사용 byte : 1 Byte short : 2 Byte int : 4 Byte long : 8 Byte 실수형 실수 값을 저장하는데 사용한다. float : 4 Byte double : 8 Byte "},"book/01.-general/data-structure/stack.html":{"url":"book/01.-general/data-structure/stack.html","title":"Stack","keywords":"","body":"스택 (Stack) 마지막에 저장한 데이터를 가장 먼저 꺼내는 후입선출 (LIFO : Last In First Out) 구조로 되어 있다. 입력과 출력이 모두 한 방향에서 이루어지는 데이터 구조 단점 바닥에 있는 데이터가 잔류하게 되는 경우가 생겨 우선순위에 관련된 문제가 생길 수 있다. 용도 지역변수의 저장 임시데이터의 백업 함수 호출의 순서 제어 인터럽트의 제어 수식계산 "},"book/01.-general/data-structure/queue/":{"url":"book/01.-general/data-structure/queue/","title":"Queue","keywords":"","body":"큐 (Queue) 처음에 저장한 데이터를 가장 먼저 꺼내는 선입선출 (FIFO : First In First Out) 구조로 되어 있다. 입출력이 양방향에서 이루어지는 데이터 구조이다. 삽입 연산을 Enqueue 삭제 연산을 Dequeue 라고 한다. 단점 데이터 삽입 후 계속 항목 삭제를 하면 REAR 와 FRONT 가 만나게 되어 공백 Queue 가 됨에도 불구하고 오버 플로우 현상이 생겨 메모리낭비 현상이 생기게 된다. 용도 OS 의 작업 스케쥴링 대기행렬 처리 유의사항 Queue 에서 데이터를 추출할 때는 첫번째 저장된 데이터를 삭제하므로 배열리스트와 같은 배열 기반 Collection Class 를 사용하면 데이터를 꺼낼때마다 빈공간을 채우기 위해 데이터의 복사가 발생한다. 이는 성능저하를 야기 시키기 때문에 연결 리스트 (Linked List) 로 구현 하는것이 적합하다. "},"book/01.-general/data-structure/queue/deque.html":{"url":"book/01.-general/data-structure/queue/deque.html","title":"DEQUE","keywords":"","body":"데큐 / 디큐 / 덱 (Deque : Double-End Queue) Queue 와 Stack 을 합쳐놓은 형태이다. 두개의 포인터를 사용하여 양쪽에서 삽입과 삭제를 발생시킬수 있다. 특징 크기가 가변적이다. 리스트와 같이 데이터를 담을 수 있는 크기가 가변적이다. 앞과 뒤에서 삽입과 삭제가 가능하다. 구현이 쉽지 않다. 랜덤 접근이 가능하다. 중간에 데이터의 삽입 및 삭제가 용이하지 않다. 되도록이면 중간에 데이터를 삽입하거나 삭제하는 것은 피해야 하며, 삽입과 삭제를 중간에 한다면 삽입과 삭제한 위치의 데이터를 모두 이동해야 한다. 중간에 데이터 삽입 시 중간에 데이터 삭제 시 Deque 를 사용하는 경우 다음과 같은 경우 Deque 를 사용하면 효과적이다. 앞과 뒤에서 삽입 혹은 삭제를 한다. STL Container 라이브러리 중에서 Deque 사용할때 성능이 가장 좋다. 저장할 데이터의 개수가 가변적이다. Deque 는 동적으로 크기가 변하므로 유연하게 사용 가능하다. 검색을 거의 하지 않는다. 많은 데이터를 저장하며 검색이 필요한 경우라면 Map, Set, HashMap 중 하나를 선택해서 사용하는편이 효과적이다. 데이터 접근을 랜덤하게 하고 싶다. Vector 와 같이 랜덤 접근이 가능하다. (사용방법도 같음) 참고자료 http://www.hanbit.co.kr/channel/category/category_view.html?cms_code=CMS3942847236 "},"book/01.-general/data-structure/queue/priority-queue.html":{"url":"book/01.-general/data-structure/queue/priority-queue.html","title":"Priority Queue","keywords":"","body":"Priority Queue (우선순위 큐) 우선순위가 높은 데이터가 먼저 작업 된다. 구현 방법 배열을 기반으로 구현 연결리스트를 기반으로 구현 힙 (Heap) 이용하여 구현 데이터가 적을때는 문제가 없지만 데이터가 많을 경우에는 노드 수에 비례해서 비교를 하기 때문에 성능저하의 이슈가 있다.따라서 주로 힙 (Heap) 을 이용하여 구현 하는 것이 일반적이다. "},"book/01.-general/data-structure/tree.html":{"url":"book/01.-general/data-structure/tree.html","title":"Tree","keywords":"","body":"트리 (Tree) 자료구조상의 트리 는 다음과 같은 특성을 가진다. 트리는 하나의 루트 노드를 가진다. 트리는 0개 이상의 자식 노드를 갖고 있다. 그 자식노드 또한 0개 이상의 자식 노드를 갖고 있으며, 이를 반복적으로 정의한다. 트리는 비 순환 그래프의 한 종류 이다. 트리의 종류 포화 이진 트리 (Full Binary Tree) 트리의 모든 노드의 깊이가 같은 완전한 이진 트리를 말한다. 완전 이진 트리 (Complete Binary Tree) 노드의 마지막 부분 (끝 부분) 을 제외하고는 모든 자식 노드를 2개를 가진 이진 트리를 말한다. 이진 트리 (Binary Tree) 트리중에서도 각 노드의 자식노드가 최대 2개 를 갖고 있는 트리를 말한다. 트리의 순회 (탐색) 트리의 순회 방식은 대표적으로 다음 4가지 (전위, 중위, 후위, 레벨) 로 나뉜다. 전위 순회 (Pre-order traversal) 루트를 방문한다. 왼쪽 노드를 방문한다. 오른쪽 노드를 방문한다. 루트 노드가 맨 처음 나온다. static void preOrder(Node n) { if (n != null) { System.out.println(n.getData() + \" \"); preOrder(n.getLeft()); preOrder(n.getRight()); } } 중위 순회 (In-order traversal) 왼쪽 노드를 방문한다. 루트를 방문한다. 오른쪽 노드를 방문한다. static void inOrder(Node n) { if (n != null) { inOrder(n.getLeft()); System.out.println(n.getData() + \" \"); inOrder(n.getRight()); } } 후위 순회 (Post-order traversal) 왼쪽 노드를 방문한다. 오른쪽 노드를 방문한다. 루트를 방문한다. static void postOrder(Node n) { if (n != null) { postOrder(n.getLeft()); postOrder(n.getRight()); System.out.println(n.getData() + \" \"); } } 레벨 순회 (Level-order traversal) 한 레벨의 모든 노드를 방문하고 다음 레벨 방문하는 방식으로레벨은 왼쪽에서 오른쪽으로 방문한다. 방문순서 : E > B > G > A > D > F > H > C 참고자료 https://gmlwjd9405.github.io/2018/08/12/data-structure-tree.htmlhttps://secmem.tistory.com/204 "},"book/01.-general/algorithm/":{"url":"book/01.-general/algorithm/","title":"Algorithm","keywords":"","body":"Algorithm Big-O 표기법 시간 복잡도 및 공간복잡도를 수치화하여 표기하며 메모리 및 성능을 기준으로 평균적인 시간 복잡도를 나타낸것으로 최선 및 최악의 수를 표현한다. "},"book/01.-general/algorithm/security/":{"url":"book/01.-general/algorithm/security/","title":"Security","keywords":"","body":"보안 대칭형 / 비 대칭형 알호 알고리즘 대칭형 알고리즘은 암호화와 복호화가 같은 KEY 값 으로 이루어 진다. 비 대칭형 알고리즘은 암호화와 복호화가 서로 다른 KEY 값 으로 이루어 진다. 이는 대부분 공개키 (Public Key) 와 개인키 (Private Key) 를 생성 하여 운영하는데 이는 다음과 같은 특징을 가진다. A의 공개키를 이용하여 암호화된 데이터는 A의 개인키로만 복호화가 가능하다.A의 개인키를 이용하여 암호화된 데이터는 A의 공개키로만 복호화가 가능하다. 대칭형 비대칭형 특징 함호화 복호화가 동일한 키 암호화 및 복호화가 다른 서로다른 키 장점 속도가 빠르다 안정성이 높다 단점 암호키를 전달하는 과정에서 노출 우려가 있다 대칭키에 비해 느리다 예 DES, AES RSA 참고자료 https://sungjk.github.io/2016/09/30/Security.htmlhttps://javaplant.tistory.com/26http://rigvedawiki.net/w/암호%20알고리즘https://o-m-i.tistory.com/209https://jusungpark.tistory.com/34 SHA-256 해싱 알고리즘의 대표적인 예인 SHA-256 은 해시 값으로 암호하여 복호화가 불가능 하다. Example import java.security.MessageDigest; public class SHA256Password { public void LockPassword(String password) { try { MessageDigest digest = MessageDigest.getInstance(\"SHA-256\"); byte[] hash = digest.digest(password.getBytes(\"UTF-8\")); StringBuffer hexString = new StringBuffer(); for (int i = 0; i 보안적인 관점 해시값은 복호화 할 수 없는데 이는 특정 문자열을 암호화하면 나오는 결과값이 다른 문자열을 해싱해서 나올수도 있기 때문이다. 홍길동 -> 홍 홍성대 -> 홍 위와 같은 원리로 결과값의 크기 (치역) 는 고정되어 있고 입력값 (정의역) 은 서로 다를 수 있기 때문이다.2² 과 -2² 의 결과 값이 서로 같은 것과 마찬가지인 원리로 결과값 4 를 기준으로 원본 데이터를 특정지을수가 없다.하지만 대표적인 비밀번호 테이블을 구비하여 해당 결과 해시값을 대조하여 일일이 찾아보는 경우가 있다 (sha 함수 테이블) 해시값의 보안성을 높이기 위하여 값을 암호화 할때 Salt 값을 넣어 해싱을 함으로써 공격의 효율을 크게 저하 시키는 방법도 유효하다. 참고자료 https://yoo-hyeok.tistory.com/41https://jusungpark.tistory.com/35 "},"book/01.-general/algorithm/sort/":{"url":"book/01.-general/algorithm/sort/","title":"Sort","keywords":"","body":"Sort 열거된 데이터를 기준 순서 (오름차순, 내림차순 등등) 에 맞게 새로 정리하는 기법을 말한다. 속도 비교 graph LR; A[\"퀵 (Quick)\"]-->B[\"합병 (Merge)\"]; B-->C[\"힙 (Heap)\"]; C-->D[\"쉘 (Shell)\"]; D-->E[\"삽입 (Insertion)\"]; E-->F[\"선택 (Selection)\"]; F-->G[\"버블 (Bubble)\"]; "},"book/01.-general/algorithm/sort/quick.html":{"url":"book/01.-general/algorithm/sort/quick.html","title":"Quick","keywords":"","body":"퀵 정렬 (Quick Sort) 정렬 알고리즘중에서 가장 빠른 정렬이다.기준이 되는 피벗 노드에 따라 성능이 좌우된다. 시간 복잡도 평균 O(n log n) 로 소요되며 일반적으로 사용될 때는 이보다 빠르다. 최악의 경우에는 O(n^2) 으로 소요 특이사항 기준이 되는 Pivot 노드에 따라 성능이 달라진다. "},"book/01.-general/algorithm/sort/merge.html":{"url":"book/01.-general/algorithm/sort/merge.html","title":"Merge","keywords":"","body":"머지 정렬 (Merge Sort) 정렬하려는 배열을 반으로 나눠 최소의 파티션으로 나누고 정렬한 후 머지하면서 정렬 시간 복잡도 O(n log n) 으로 퀵 정렬 과 같다. 특이사항 별도의 저장 공간이 필요 하다. Example Case 1 : JS - ES5 var arr = [6, 3, 8, 4, 1, 9, 2, 5, 7, 0]; function MergeSort(arr) { this.arr = null; if (arr instanceof Array) { this.arr = arr; return this.sort(arr); } } MergeSort.prototype = (function () { function sort(arr) { if (typeof arr === 'undefined' || !(arr instanceof Array)) { if (!(this.arr instanceof Array)) { throw new Error('Array object is not exist'); } arr = this.arr; } if (arr.length === 1) { return arr; } var mid = Math.floor(arr.length / 2), left = arr.slice(0, mid), right = arr.slice(mid); return merge(sort(left), sort(right)); } function merge(left, right) { var answer = [], leftLength = left.length, rightLength = right.length, leftIdx = 0, rightIdx = 0; while (leftIdx console.log(new MergeSort(arr)); var ms = new MergeSort(); console.log(ms.sort(arr)); "},"book/01.-general/algorithm/sort/insertion.html":{"url":"book/01.-general/algorithm/sort/insertion.html","title":"Insertion","keywords":"","body":"삽입 (Insertion) 전체요소에서 가장 작은 데이터를 찾아 가장 앞의 데이터와 교환하는 방식 const array = [5, 3, 1, 4, 2]; let len = array.length, i = 1, j, temp; for (; i 0 && array[j - 1] > temp) { array[j] = array[j - 1]; j--; cnt++; } array[j] = temp; } console.log(array.join(' ')); "},"book/01.-general/algorithm/sort/selection.html":{"url":"book/01.-general/algorithm/sort/selection.html","title":"Selection","keywords":"","body":"선택 (Selection) 전체 요소에서 기준 위치에 맞는 원소를 선택하여 교환하는 방식 "},"book/01.-general/algorithm/sort/bubble.html":{"url":"book/01.-general/algorithm/sort/bubble.html","title":"Bubble","keywords":"","body":"버블 (Bubble) 왼쪽 끝에서 부터 인접하는 두 항목의 값을 비교하여 서로 위치를 교환하는 정렬 방법 "},"book/01.-general/bi/":{"url":"book/01.-general/bi/","title":"Business Intelligence","keywords":"","body":"비지니스 인텔리전스 (BI : Business Intelligence) "},"book/01.-general/bi/dw.html":{"url":"book/01.-general/bi/dw.html","title":"Data Warehouse","keywords":"","body":"Data Warehouse 기업의 의사 결정을 지원하기 위한 데이터를 모아놓은 통합적인 자료의 집합이다. 이는 주제 중심적으로 모아놓았으며 다양한 운영 시스템에서 추출 및 변형과정이 일어난 읽기 전용 데이터 베이스이다. 특징 주제 중심적 (Subject Oriented) 각 조직의 주요 주제를 중심으로 관련 데이터를 구성 통합 구조 (Integrated) 업무 기능별로 관리되는 다수의 운영 데이터를 전사적 관점에서 중복을 최소화하고, 모든 업무에 공유할 수 있도록 통합 데이터의 정합성과 통일성을 갖는 데이터 구조의 지원 시계열 데이터 (Time Variant) 데이터는 오랜 기간 동안 보유되며 과거와 현재의 경향 분석이 가능하도록 모든 순간의 값을 유지 비 휘발성 데이터 (Non Volatile) 초기 데이터 적재 이후에는 데이터의 갱신은 발생하지 않고 검색만 가능 데이터 갱신 이상에 대한 고려가 필요없으며, 정규화 및 반정규화에 대한 융통성의 증가 모델링 기법 주로 ETL 툴을 이용하여 구축하기도 하며 대부분은 스타 스키마 (Star Schema) 구조로 구성된다. 스타 스키마 (Star Schema) 모델링의 구조가 별 모양이라 스타라는 이름이 명명됨 차원 (Dimension) : 수치를 한정짓게 하는 일종의 키 역활을 한다. (필터, 정렬 등등이 포함된다) 수치 (Measure) : 실제로 의미있는 값을 지칭한다. 팩트 테이블 (Fact Table) : Measure 정보를 포함한 테이블을 말한다. 데이터 마트 (Data Mart) 이해관계가 동일한 사용자 집단에 특화된 데이터 로서 대부분은 DW 로 부터 복제되지만 자체수집 되는 경우도 있다. 특정 사용자 집단에 대한 접근성과 가독성을 높이는데 초점 이 맞춰져 있으며 많은 부분들이 요약된 데이터로 제공 된다. 메타 데이터 (Meta Data) 데이타에 대한 데이타라고 할 수 있다. 데이터의 위치정보라던지 혹은 데이터간의 관계와 같은 데이터의 명세를 가지고 있는 정보이다. 데이터 마이닝 (Data Mining) 대규모로 저장된 데이터 안에서 특정 규칙이나 패턴을 발견해내는 과정을 말한다. 일부에서는 데이터 디스커버리라는 용어로 서술하기도 한다 (ex. MicroStrategy) 참고자료 https://middleware.tistory.com/entry/데이터-웨어하우스Data-Warehouse-및-데이터-마트Data-Marthttp://blog.daum.net/_blog/BlogTypeView.do?blogid=0J2W5&articleno=74&_bloghome_menu=recenttext "},"book/01.-general/ide.html":{"url":"book/01.-general/ide.html","title":"IDE","keywords":"","body":"IDE VSCode extension package BreadCrumb in StatusBar 선택 파일 경로 노출 GitLens 선택 행 깃 커밋 보여주기 One Dark Pro 에디터 테마 vscode-icons 에디터 아이콘 Material Icon Theme 에디터 아이콘 Markdown lint 마크다운 문법 검사 https://github.com/DavidAnson/vscode-markdownlint Bracket Pair Colorizer 코드 블럭 브라켓 https://github.com/CoenraadS/Bracket-Pair-Colorizer-2 usersetting.json { \"workbench.startupEditor\": \"welcomePage\", \"gitlens.advanced.messages\": { \"suppressCommitHasNoPreviousCommitWarning\": false, \"suppressCommitNotFoundWarning\": false, \"suppressFileNotUnderSourceControlWarning\": false, \"suppressGitVersionWarning\": false, \"suppressLineUncommittedWarning\": false, \"suppressNoRepositoryWarning\": false, \"suppressResultsExplorerNotice\": false, \"suppressShowKeyBindingsNotice\": true, \"suppressUpdateNotice\": false, \"suppressWelcomeNotice\": true }, \"java.home\": \"/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home\", \"window.openFilesInNewWindow\": \"on\", \"window.zoomLevel\": 0, \"editor.tabSize\": 2, \"editor.fontFamily\": \"D2Coding ligature\", \"editor.fontLigatures\": true, \"editor.fontSize\": 14, \"gitlens.keymap\": \"alternate\", \"gitlens.historyExplorer.enabled\": true, \"workbench.colorTheme\": \"One Dark Pro Vivid\", \"breadcrumbs.enabled\": true, \"workbench.iconTheme\": \"vscode-icons\", \"material-icon-theme.folders.theme\": \"specific\", \"java.errors.incompleteClasspath.severity\": \"ignore\", \"markdownlint.config\": { \"MD001\": false, \"MD024\": false, \"MD026\": false, \"MD033\": false } } .eslintrc { \"env\": { \"jquery\": true, \"browser\": true, \"amd\": true, \"commonjs\": true, \"es6\": true }, \"parser\": \"babel-eslint\", \"parserOptions\": { \"ecmaVersion\": 6, \"sourceType\": \"module\", \"ecmaFeatures\": { \"jsx\": true } }, \"globals\": { \"alert\": false, \"clearTimeout\": false, \"clearInterval\": false, \"document\": false, \"exports\": false, \"module\": false, \"navigator\": false, \"require\": false, \"setInterval\": false, \"setTimeout\": false, \"window\": false, \"XMLHttpRequest\": false }, \"rules\": { \"camelcase\": [\"error\", {\"properties\": \"always\"}], \"comma-spacing\": [\"error\", {\"before\": false, \"after\": true}], \"comma-style\": [\"error\", \"last\"], \"comma-dangle\": \"error\", \"brace-style\": [\"error\", \"1tbs\", { \"allowSingleLine\": true }], \"indent\": [\"error\", 2, { \"SwitchCase\": 1 }], \"valid-jsdoc\": [\"warn\", {\"requireReturn\":false}], \"block-scoped-var\": \"warn\", \"curly\": \"error\", \"eqeqeq\": \"warn\", \"quotes\": [\"error\", \"single\"], \"semi\": \"error\", \"no-inline-comments\": \"warn\", \"no-debugger\": \"error\", \"no-console\": \"warn\", \"no-empty\": \"warn\", \"no-spaced-func\": \"warn\", \"no-array-constructor\": \"error\", \"no-undefined\": \"warn\", \"no-alert\": \"off\", \"no-loop-func\": \"error\", \"no-multi-spaces\": \"error\", \"no-new\": \"error\", \"no-unused-expressions\": \"error\", \"no-unused-vars\": \"warn\", \"no-use-before-define\": [\"error\", {\"functions\": false}], \"space-before-blocks\": \"error\", \"semi-spacing\": [\"error\", {\"before\": false, \"after\": true}], \"keyword-spacing\": [\"error\", {\"before\": true, \"after\": true}], \"no-new-object\": \"error\", \"key-spacing\": [\"error\", {\"beforeColon\": false, \"afterColon\": true}], \"space-infix-ops\": [\"error\"], \"space-before-function-paren\": [\"error\", {\"anonymous\": \"always\", \"named\": \"never\"}] } } "},"book/01.-general/interview/":{"url":"book/01.-general/interview/","title":"Interview","keywords":"","body":""},"book/01.-general/interview/frontend.html":{"url":"book/01.-general/interview/frontend.html","title":"FrontEnd","keywords":"","body":"FE 면접 질문 HTML Inline 요소와 Block 요소의 차이점 ? Inline 요소 : 브라우저에서 줄바꿈 없이 사용 가능한 엘리먼트 (, , ...) Block 요소 : 브라우저에서 줄바끔 요소가 적용된 엘리먼트 (, , , ...) 시맨틱 / 구조적 마크업 검색엔진을 통하여 검색이 문서검색 혹은 크롤링이 가능하게 접근성을 높인 마크업 CSS Selector 에서 body > div 와 body div 의 차이점 ? body > div : 상위 노드가 body 태그를 가지는 div 태그 body div : 상위 노드들 중에 body 태그를 가지는 div 태그 CSS Position 중에 static, relative, absolute, fixed 의 차이점 static : 포지션 설정을 하지 않았을 때 static relative : 상대적인 위치정보를 지정할때 사용 absolute : 절대적인 위치정보를 지정할때 사용 fixed : 고정된 위치정보를 지정할때 사용 Reset CSS 란 ? 브라우저와 상관 없이 같은 모양을 나타내도록 CSS 를 초기화 하는것을 말함 normalize css 라는 것과 유사하지만 강제로 초기화 시키는 reset css 와는 다르게 브라우저별 차이를 보이는 부분만 혹은 디자인적인 요소를 가미해서 reset 를 해준다는 차이점이 있다. CSS BOX MODEL 에 대해 설명 Margin, Border, Padding, Width & Height 등을 그림을 그려서 설명 IR 기법이란 ? 이미지를 대체할 엘리먼트를 배경 이미지로 설정하고 태그와 같은것으로 감싸면서 안보이게 처리 자바스크립트에서 null 과 undefined 차이점은 ? null 은 값이 null 이 할당된 것 undefined 는 아무런 값이 할당되지 않는것 typeof 로 확인해보면 null 은 object 로 확인되며 undefined 는 undefined 로 확인 가능 == 와 === 의 차이점은 ? 값만 같다 혹은 타입까지 같다의 차이점이다. == 인 경우 자바스크립트에서는 타입이 같도록 형변환 과정을 거친후 값을 비교한다. 자바스크립트는 type safe 한 언어가 아니기 때문에 이러한 차이점이 있다. (java 는 type safe 한 언어임) Hoisting 이란 ? 함수의 선언과 변수의 선언이 해당 유효범위 상위로 옮겨지며 변수는 undefined 를 기본값으로 갖는 현상 함수의 표현식은 해당되지 않으며 같은 변수명과 함수명이 있을경우 변수명이 우선순위가 높아짐 ES6 에서도 호이스팅이 지원안되는것이 정설이지만 TDZ 관점에서 없다고 봐도 무관하기 때문이다. 임의적 사각지대 (TDZ : Temporal Dead Zone) 초기화 (선언) 가 되지 않는 객체들을 참조 할 수 없다.(호이스팅이 되지 않는것은 아님 - ES5 처럼 undefined 로 선 할당이 안됨) DOM Event Model 에서 Bubbling 과 Capturing 의 차이점은 ? Bubbling : 자식노드 이벤트가 일어났을 경우 부모까지 이벤트가 전파되는 현상 Capturing : 부모에서 자식으로 이벤트가 전달되는 현상 DOM Delegation 으로 이어서 설명해야 함 DOM Delegation 이란 ? Event Bubbling 이나 Capturing 이 일어날때 성능적인 이슈가 일어나거나 혹은 새로 추가되는 요쇼의 이벤트 바인딩이 주기적으로 필요할 경우 사용하는 이벤트 위임 방법이다. 이벤트 타겟의 부모에 이벤트를 걸어준 뒤 발생되는 이벤트 타입과 셀렉터를 체크하여 제어하는 식이다. 웹 성능 튜닝시 사용하는 도구는 ? 브라우저의 디버깅 도구, Google Pagespeed Insight, webpagetest.org dynatrace, showslow 등등을 활용 Ajax 사용시 타겟의 URL 도메인이 다른 경우 해결 방법 ? JSONP, CORS 등을 이용하여 해결 JSONP : DOM 트리에 추가되면 외부 스크립트를 로드할 수 있는것에서 착안하여 사용 동일 출처 정책 (SOP : Same Origin Policy) 에 포함되지 않음 최근 FrontEnd 동향 / 라이브러리 / 프레임워크 / 스팩 / 기능 들의 관심있는 분야? vue > React > 템플릿 리터럴즈 (유인동) 이라고 보고 있다 (19/02) 바닐라 JS 를 좋아하기 때문에 ... 다음 상황을 구현하기 위한 방법을 서술하시요 온라인 이메일 웹서비스를 구현한다고 가정하자. 이 페이지에는 리프레시 버튼이 하나 있는데, 이 버튼을 누르면 페이지를 다시 로딩하지 않고 새로 도착한 메일을 가져와 화면에 표시해주는 기능을 수행하여야 한다. 이를 어떻게 구현해야하는지 최대한 상세히 설명하시오. 서버측 구현은 이미 다 되어있다고 가정한다. DOM Event 처리 동작, DOM 조작, XHR 또는 JSONP / CORS 등등과 같은 내용들을 덧붙여 설명한다. 웹 접근성이란 ? 기본적인 웹 표준 준수 및 접근성에 대한 내용을 설명 시각 장애인들을 위한 TTS 나 약시, 색약, 지체 장애인들에 대한 대응 바로가기링크 명도대비 준수 깜빡임 빈도 클릭영역의 크기 alt 대체 텍스트와 같은 기능적인 것들을 포함 JSON 과 JSONP 의 차이점 ? JSON 은 Java String Object Notation 으로 데이터를 구조화된 데이터를 표현하기 위한 객체이며 JSONP 는 Ajax 에서 CORS 이슈 발생시 우회 방법으로 사용하는 통신 방식이다. 자바스크립트의 Scope Chain 에 대해서 설명 변수가 접근 가능한 유효범위를 말한다. 함수단위로 유효범위가 변하며 내부 함수로 진입시 새로운 스코프가 Stack 형태로 구성된다. Scope Chain 은 하위에서 상위로 등록된 변수가 있는지 확인한다. 자바스크립트의 클로져란 ? 유효범위를 가지는 코드 블럭 상위의 스코프로 변수참조가 일어나는것을 말한다. 모듈 패턴에 대해서 설명 코드를 모듈화 시켜 변수의 범위를 제한하는 패턴 public 과 private 한 유효범위를 가질 수 있다. 브라우저 랜더링 과정을 설명 HTTP Request > (서버) > HTTP Response > HTML 파싱 > CSS / JS Request > 파싱 > DOM 트리 > 렌더트리 > 페인트 다음 상황에 대해 설명하시오 서버는 응답을 빠르게 출력하고 있지만 웹 페이지가 늦게 뜨고 있다. 웹 사이트를 최적화 하기 위한 방법은 ? 서버 Request 횟수 CSS / JS 를 minify 하여 사용 gzip 전송 이미지 최적화 및 Lazy 로딩 사용 CDN 사용 JS 파일은 async / defer 사용 랜더링 최적화 마크업 복잡도를 단순화 reflow 혹은 repaint 최소화 다양한 크기의 화면 대응 및 멀티 플렛폼에 대한 대응 방안 ? 각 디바이스별 최적화를 위한 방법들 반응형 디자인을 위한 미디어 쿼리를 사용 ES5 / ES6 의 차이점은 ? const, let promise spread operator rest parameter screenX, pageX, clientX, offsetX, layerX 의 차이점은 ? screenX : 모니터 기준 pageX : document 기준 clientX & offsetX : 브라우저 기준 offsetX : 타겟 기준 서버로부터 받은 응답은 잘 받은 상태지만 웹 페이지가 비정상 적으로 렌더링 되어 있다고 가정하면 어떤 문제가 있을까 ? JS 오류 무한루프 문법 비 정상 접근 서버 응답 오류 DOM 파싱 오류 닫는 태그의 오류 문서모드 및 메타태그 정보 오류 페이지 인코딩 querySelector 와 jQuery Selector 의 차이점 ? querySelector : 반환이 1개 jQuery Selector : 반환값이 여러개 복수 (querySelectorAll 과 같음) querySelector 에서는 class 로 많이 사용을 안하고 attribute 로만 사용 (성능적인 측면 때문에 / data 속성이 제일 빠름) 자바스크립트에서 Iteration Method 에 대해서 설명 Symbol.Iterator 속성을 갖는 객체를 Iterable 한 객체라고 한다. Array.Prototype.forEach : 모든 엘리먼트를 callback 에 넘겨 실행 Array.Prototype.map : 인자로 넘겨진 엘리먼트를 새로운 배열로 리턴 Array.Prototype.filter : 조건에 맞는 값들로 새로은 배열로 리턴 자바스크립트에서 var 를 사용하지 않으면 발생되는 현상 ? 전역 프로퍼티로 등록 된다. use strict (엄격모드) 구문을 사용하여 방지 가능하며 eslint 를 사용하면 동일한 효과 가장 큰 차이점은 삭제가 가능하다는 점 RESTful 개발시 HTTP Method 를 설명 POST : 리소스를 생성 GET : 리소스를 요청 PUT & PATCH : 리소스를 변경 DELETE : 리소스를 삭제 그래픽 처리시에 백터와 비트맵의 차이점 Vector : 방향기반 (SVG) Bitmap : 화소기반 (Canvas) SPA 에서의 뒤로가기 앵커나 해시뱅 (#!) 를 통한 히스토리 조작 pushState 를 이용한 히스토리 조작 방법 Promise 란 ? 비동기로 작업을 순차적으로 처리하기 위한 패턴 then then 구문으로 사용 "},"book/01.-general/interview/backend.html":{"url":"book/01.-general/interview/backend.html","title":"BackEnd","keywords":"","body":"BE 면접 질문 Integer 의 바이트는 ? 4Byte short integer 의 최하 / 최상 값은 ? -32,768 ~ 32,767 unsigned Integer 는 ? 일반적으로 unsigned int 는 부호비트를 값 비트로 쓸수 있어서 2^32 -1 (4294967295) 값을 가진다. Java 에서는 unsigned int 값이 없으며 long 으로 대체하여 사용한다. Compiler 와 Interpreter 의 차이점 Compiler 는 문서 전체를 다 읽어 기계어로 번역한다. (구문 -> 목적 프로그램) Interpreter 는 한줄한줄 행 단위로 읽어서 처리한다. (구문 -> 명령문) Java 에서 instanceof 연산자란 ? 참조 변수가 실제로 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof 연산자를 사용 Stack 과 Heap Memory 장단점과 해제 방법을 설명 Stack 빠른접근, cpu 에 의해 관리, 지정된 크기, resize 불가 해제 : 자동 Heap 전역적으로 접근 가능, 메모리 크기 제한 없음, resize 가능하나 파편화가 가능 해제 : 수동 Quick Sort 란 무엇이고 시간복잡도는 어떻게 되는지 설명 일반적으로 정렬 알고리즘중에서 빠르다고 알려진 알고리즘 시간 복잡도 Best : n log n Worst : n^2 Average : n log n Pivot 선택노드가 속도에 영향을 줄 수 있음 Java 에서 public static void main( ... ) 으로 시작할 때 public 과 static 을 붙이는 이유는 ? 메인 메서드는 진입점 (Entry Point) 를 뜻하며 접근제어자가 public 이 되어야 함 함수에 static 을 붙이게 되면 instance 화 되기 전에 호출 가능하다. 클래스 멤버는 메모리에 로딩된 다음에 사용이 가능하다 main 함수는 프로그램 최초에 호출되는 함수이기 때문에 객체 생성 이전에 호출할 수 있어야 한다. static 이 붙은 클래스나 메서드, 변수는 컴파일시 자동으로 로딩 관심의 분리 (Separation Of Concern) 에 대해 설명하고 예를 들어 설명 서비스 지향 아키텍쳐 (SOA : Service-Oriented Architecture) 의 핵심 원칙 관심이 같은것은 뭉치고 관심사가 다른것은 서로 떨어져 영향을 주지 않도록 설계 및 구현을 하는것 AOP 이란 ? 비지니스 로직과 공통모듈을 분리하여 핵심로직에 영향을 미치지 않고 사이사이에 공통모듈을 효과적으로 잘 끼워넣는 개발방법 공통모듈은 보안, 인증, 로깅 같은 것을 만든 후에 코드 밖에서 이 모듈을 비지니스 로직에 삽입하는것이 AOP 개발 방법이다. 코드 밖에서 설정된다는것이 핵심이며 프로그램 흐름을 파악하기 힘들기 때문에 AOP 사용이 많아질경우 유지보수가 어렵다. BDD 란 무엇이고 TDD 와 어떤 연관이 있나 ? Behavior Driven Development (행위 주도 개발) 의 약자이다. BDD 는 소프트웨어의 수행을 위한 것으로 TDD 접근법을 전환한것이다. String vs StringBuffer 차이점은 ? String Class 인 경우 Character 조작을 위한 것이며 단순한 상태값을 가지고 있는 불변 속성이다. StringBuffer Class 인 경우 문자열을 재구성하기 위한 것이며 수정이 가능하다. CheckedException 과 UncheckedException 의 차이와 용도를 설명 Checked Exception 외부상황에 의해 미리 예상 가능한 오류이다 예) 디스크 오류, 네트워크 오류등 로직 상의 오류와는 무관하게 발생하는 에러. IOException, ClassNotFoundException, CloneNotSupportedException등등 RuntimeException을 제외한 Exception을 직접 상속한 모든 예외 클래스는 Checked Exception. Unchecked Exception 프로그램 로직 상에 문제로 인해 생기는 오류이다. RuntimeException 이하 모든 하위클래스는 Unchecked exception이다. 발생한 예외에 대하여 반드시 코드상에서 예외 처리를 하도록 요구하지 않는다. NullPointerException의 경우 null을 참조하려는 시도는 프로그램 코드 자체가 잘못된 것. 이런 예방 할 수 없는 오류 조건들은 로직 상에서 처리를 요구 객체 재사용이란 무엇인가 ? Singleton Instance 와 같이 최초에 한번 생성한 후 재사용하는 것 ThreadPool, ConnectionPool 등 이외에도 코드내에서 객체를 재사용하는 방법이 있다. StringBuffer sb = new StringBuffer(); sb.append(“data1”); System.out.println(sb); sb.setLength(0); "},"book/02.-front-end/":{"url":"book/02.-front-end/","title":"02. Front End","keywords":"","body":"02. Front End SPA 환경의 뒤로가기 기존의 페이지 이동을 통한 뒤로가기 URL 을 직접적으로 조작하여 페이지를 이동하는 방식 앵커를 이용한 방식 앵커를 이용한 방식은 서버로 전달되지 않기 때문에 프론트에서 제어가 가능하다. 이후에 해시뱅 (#!) 이라는 기법을 통하여 URL 과 유사하게 포장했다. 해시뱅은 다음과 같은 치명적인 단점 이 있다. 자바스크립트가 동작하지 않으면 사이트 전체가 동작하지 않기 때문에 자바스크립트 로딩 & 파싱이 정상적으로 완료 해야 한다. 크롤링의 제한 브라우저 캐시를 정상적으로 사용불가 네트워크 중개서버가 핸들링이 안되기 때문에 모든 트래픽을 다루어야 한다. pushState 를 이용한 방식 HTML5 에 새로 추가된 History API 의 한 방식으로 IE 10 이상에서 사용 가능한 방식이다.브라우저의 히스토리를 조작 하여 사용하는 방식 참고자료 https://blog.outsider.ne.kr/1276 "},"book/02.-front-end/01.-html/":{"url":"book/02.-front-end/01.-html/","title":"01. HTML","keywords":"","body":"01. HTML DTD (Document Type Definition) HTML 에서 문서 형식을 지정하는 것을 DTD 라고 하며 DTD 는 HTML 문서에 첫번째 줄에 위치해야 한다. 문서형식은 HTML 버전과 종류를 명시함으로써, 브라우저가 문서를 해석하고 출력하는데 직접적으로 영향 을 준다. 올바르게 문서형식이 지정된 경우에는 표준 (Strict) 방식, 그렇지 않는 경우에는 호환 (Quirks) 방식으로 출력한다. 호환 출력 방식 (Quirks Rendering Mode) 특징 브라우저가 HTML 을 랜더링 (읽기, 해석, 출력) 하는 시간이 더 걸린다. 브라우저마다 HTML 출력을 각각 다르게 출력한다. Example #1 : HTML onload object 가 로드 되었을 때 발생 합니다.웹 페이지가 모든 컨텐츠 (이미지, 스크립트 파일, 스타일시트) 등을 완전히 로드한 후 실행 합니다. Syntax object.onload = function () {/* script */}; object.addEventListener('load', script); $(document).ready vs $(window).load 차이점 두 이벤트 리스너 모두 jQuery 라이브러리를 필요로 하며 차이점은 아래와 같다. ready 이벤트는 DOM 이 로드되고 Element 의 접근이 안정될 때 발생한다. load 이벤트는 DOM 과 모든 Asset (이미지, 문서 등등...) 들이 로드된 이후에 발생한다. Syntax $(document).ready(function () { /* statement */ }); $(window).load(function () { /* statement */ }); Vanilla JS IE 9 이상 document.addEventListener('DOMContentLoaded', function () { /* statement */ }); IE8 이하 IE8 이하에서는 아래와 같이 사용해야 한다. document.onreadystatechange = function () { if (document.readyState === 'complete') { /* statement */ } }; readyState 에 필드 값 유형 readyState Description uninitialized 아직 로딩이 시작되지 않음 loading 로딩중 interactive 어느정도 로드가 되었으며 사용자가 상호작용 할 수 있음 complete 로딩 완료 window.onload = function () { /* statement */ } 참고자료 https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onload Detail Feature Description 이벤트 버블링 NO 중단 가능 여부 NO 이벤트 유형 UI 생성시 지원 태그 , , , , , , , DOM 버전 Level 2 이벤트 시맨틱 (Semantic) 마크업 브라우저가 웹 문서 (HTML) 를 정확히 읽어내기 위하여 정보의 의미에 맞는 HTML Tag 를 이용하여 작성하는 것출력 형태는 와 별 차이는 없다. 장점 웹 접근성이 좋아짐 SEO (Search Engine Optimization) 개선 효과 코드 가독성, 재사용성이 높아짐 대표적으로 가 있다. 태그 설명 section 문서의 구획 (예: 장, 절) article 독립된 콘텐츠 영역 (예: 개별 신문기사) nav 네비게이션 메뉴 영역 aside 부가 콘텐츠(예: 사이드바, 광고 등) 본문 내용과 비교적 관련성이 적은 것 header 헤더글. 본문 위에 첨가하는 짧은 글 영역 footer 바닥글. 본문 아래에 첨가하는 짧은 글 영역 hgroup 제목(h1 ~ h6) 을 그룹화하는 요소 "},"book/02.-front-end/01.-html/canvas.html":{"url":"book/02.-front-end/01.-html/canvas.html","title":"Canvas","keywords":"","body":"Canvas HTML5 에 추가된 HTML 요소는 JavaScript 의 스크립트를 통하여 그래픽을 그리는데 사용된다. "},"book/02.-front-end/01.-html/performance/":{"url":"book/02.-front-end/01.-html/performance/","title":"Performance","keywords":"","body":"Performance "},"book/02.-front-end/01.-html/performance/browser-render.html":{"url":"book/02.-front-end/01.-html/performance/browser-render.html","title":"Browser Render","keywords":"","body":"HTML 랜더링 순서 HTML 속도 개선을 위해서는 기본적인 먼저 랜더링 순서를 파악하고 이를 개선해야 한다. graph LR A[HTML] -- HTML Parse --> B[DOM Tree] B --> C[Render Tree] D[CSS] -- CSS Parse --> E[CSS Object Model] E --> C C --> F[Reflow] F --> G[Repaint] 사용자가 브라우저에 URL을 입력하거나 이동을 한다. 브라우저 인터페이스 엔진에서 해당 작업을 분석 한다. 페이지 이동이 확인되면 해당 서버에 정보를 요청 한다. 도메인의 경우 DNS Lookup 을 통하여 서버 IP 경로를 얻어온다. 얻어온 서버 경로로 필요한 경로 정보를 요청 한다. (3 Way Handshake) HTTP 요청 응답이 MIME 타입을 확인하여 해당 자원을 다운로드 한다. 다운로드 된 HTML 및 CSS 문서를 해석하는 과정을 거친다 HTML 을 해석하여 DOM Tree 구성을 한다. CSS 를 해석하여 CSSOM (Cascading Style Sheets Object Model) 을 구성한다. 위 두 구성이 모두 완료 하여야만 다음 진행이 가능하다. (CSS : 랜더링 블라킹 요소) 이후 자바스크립트 태그 혹은 구문을 만나면 약속된 프로세스 (비차단 스크립트) 대로 진행 한다. DOM Tree & CSSOM 이 완료 되면 Render Tree 구성을 진행한다. CSS 규칙중 {display:none} 을 만나면 Render Tree 구성에서는 빠진다. (DOM Tree 에는 존재) Render Tree 구성이 완료되면 Reflow 작업을 통하여 필요한 레이아웃을 화면에 배치한다. Reflow 작업이 완료 되면 Repaint 과정을 통하여 화면에 배치한 레이아웃을 그린다. HTML 개선 방안 HTML 랜더링 속도를 올리는 방법에는 다음과 같은 방법이 있다. HTTP Request 최소화 서버에 자원의 요청을 최소화 하는 방법으로 네트워크 레이턴시를 줄여 성능을 개선한다. Resource 압축 정적 리소스 (HTML, JS, CSS) 의 소스를 압축 (manifest) 하여 제공하는데JS, CSS 는 모듈 번들러 (webpack, manifest ... ) 를 통하여 제공하고HTML 은 gzip 전송을 한다. Reflow, Repaint 최소화 추가적으로 브라우저에서 Reflow 를 일으킬만한 요소들을 최소화 하기 위하여 다음 가이드라인을 참고한다. 사용자의 브라우저 별로 리플루우 (Reflow) 가 걸리는 시간도 상이 하지만 대부분의 리플로우를 일으키는 조건은 동일하여 아래의 가이드라인을 통하여 충분히 개선이 가능하다. 불필요한 DOM Depth를 줄인다. DOM Tree 의 Depth 하나를 변경하면 트리의 모든 Depth 에 따라 더 많은 시간이 소요된다. 부모로는 Root, 자식은 Update 된 Node 까지 변경 될 가능성이 있음 CSS 규칙을 최소화 하고 사용하지 않는 CSS 규칙을 삭제한다. 애니메이션과 같이 복잡한 랜더링 요소는 흐름의 밖에서 변경한다. 변경시에는 절대 위치 혹은 고정 위치를 사용한다. 불필요하거나 복잡한 CSS 선택기 하위요소 선택기를 사용하지 않는다. 선택기와 일치시키기 위해서 더 높은 GPU 처리량의 필요가 요구된다. 그 외 방법들 이미지 최적화 큰 이미지를 CSS 로 잘라서 사용 BASE 64 Encoding 전송 브라우저 캐싱 사용 방문 리다이렉션 사용 안함 참고자료 https://developers.google.com/speed/docs/insights/browser-reflow?hl=kohttp://lists.w3.org/Archives/Public/public-html-ig-ko/2011Sep/att-0030/Reflow_____________________________Tip.pdfhttp://www.stubbornella.org/content/2009/03/27/reflows-repaints-css-performance-making-your-javascript-slow/ "},"book/02.-front-end/02.-css.html":{"url":"book/02.-front-end/02.-css.html","title":"02. CSS","keywords":"","body":"02. CSS 스타일 태그 위치 태그에 위치 시켜야 한다. 하단에 위치 시키게 되면 HTML 파일을 두 번 읽어서 적용 시키기 때문 inline & inline block {display: inline;} 대표적으로는 태그의 성질로 content/text 크기만큼만 점유하고 동일 라인에 붙는 성질이다. width height 적용 불가 margin padding-top padding-bottom 적용 불가 line-height 원하는대로 적용 불가 ( 에 적용 안되고 감싸고 있는 전체 크기에만 영향을 줌) {display: block;} 무조건 한줄을 점유한다. {display: inline-block;} {display: inline;} 과 {display: block} 의 혼합된 형태로 대부분의 inline 특성을 가져갑니다. width/height 적용 가능 margin/padding-top/padding-bottom 적용 가능 line-height 적용 가능 {display: block} 끼리 공백이 생기게 되는데이는 상위 에 {font-size: 0} 를 적용하면 해결 가능하다. 참고자료 https://blog.naver.com/leesd88/220682157303 Keyframes @keyframes ANIMATION_NAME_1 { from {opacity: 0;} to {opacity: 1;} } @keyframes ANIMATION_NAME_2 { 0% {opacity: 0;} 25% {opacity: 0.25;} 50% {opacity: 0.5;} 75% {opacity: 0.75;} 100% {opacity: 1;} } .CLASS_NAME {animation: ANIMATION_NAME_1 3s infinite;} Animation 에 대한 적정한 사용 CSS Animation : 간단한 UI 요소 JS Animation : 바운스, 중지, 일시정지, 되감기, 가속 등과 같은 고급효과 "},"book/02.-front-end/03.-javascript/":{"url":"book/02.-front-end/03.-javascript/","title":"03. Javascript","keywords":"","body":"03. Javascript 공백 체크 Example #1 : JS - ES5 var blankPattern = /^\\s+|\\s+$/g; console.log(' '.replace(blankPattern, '')); // \"\" console.log(blankPattern.test('')); // false console.log(blankPattern.test(' ')); // true 조건문 Javascript 에서 if 문에 들어가는 조건식이 다음과 같은 제한 사항을 갖는다. Example #1 : JS - ES5 console.log(null ? 'A' : 'B') // B console.log(undefined ? 'A' : 'B') // B console.log('' ? 'A' : 'B') // B console.log(0 ? 'A' : 'B') // B console.log(' ' ? 'A' : 'B') // A console.log(-1 ? 'A' : 'B') // A "},"book/02.-front-end/03.-javascript/01.-general/":{"url":"book/02.-front-end/03.-javascript/01.-general/","title":"01. General","keywords":"","body":"01. General Strict Mode (엄격 모드) 스크립트 상단 혹은 함수의 시작 부분의 'use strict' 을 선언하면 Strict Mode 로 코드를 작성 할 수 있다. 'use strict'; /* statement */ function foo () { 'use strict'; /* statement */ } Strict Mode 는 문법검사와 런타임 동작을 검사해주는 기능을 하는데 그 역활은 다음과 같다. 경고를 에러로 변환 read only 객체는 수정불가 get 으로 선언된 객체는 수정불가 extensible 특성이 false 로 설정된 객체의 속성 확장 불가 delete 연산 사용 불가 Literal Object 의 동일한 이름의 Property 생성 불가 8 진수 및 Literal 및 escape 문 사용 불가 참고자료 http://beomy.tistory.com/13 일급객체 (First-Class Object) 자바스크립트는 일급객체 (First-Class Object) 입니다.일급 객체 (First-Class Object) 는 다음과 같은 특징을 갖습니다. 일급 객체는 변수에 저장 가능 해야 한다. 일급 객체는 함수의 파라미터로 전달할 수 있어야 한다. 일급 객체는 함수의 반환값으로 사용할 수 있어야 한다. 일급 객체는 자료구조에 저장할 수 있어야 한다. JSONP 웹 브라우저는 SOP (same origin policy: 동일출처정책) 에 따라 서로 다른 도메인간의 데이터 통신을 제한하고 있다script 코드가 DOM 트리에 추가되어 실행되면 외부 스크립트를 로드할 수 있다는 것 에서 착안 태그는 SOP 정책에 속하지 않기 때문에 jsonp (json width padding) 이 사용됨 JSONP 의 callback 은 서버에서 지원 해줘야 정상적으로 사용이 가능 스크립트 태그 삽입으로 callback 함수 jsonp 구현하기 var callback = '_callback_jsonp_' + Math.round(10000 * Math.random()); var script = document.createElement('script'); script.src = 'http://localhost:8080/getJSON.json?callback=' + callback; document.body.appendChild(script); window[callback] = function (data) { delete window[callback]; /* 콜백 실행 로직 */ } 요청 URL 뒤에 callback 파라메터 추가하여 jsonp 요청 구현하기 Client $.getJSON('/jsonp.json?callback=?', function (data) { console.log('success: ', data); }); Server private void doGet(HttpServletRequest request, HttpServleteResponse response) throws ServletException, IOException { request.setCharacterEncoding(\"UTF-8\"); response.setCharacterEncoding(\"UTF-8\"); String id = request.getParameter(\"id\"); String callBack = request.getParameter(\"callback\"); JSONObject obj = new JSONObject(); obj.put(\"result\", id); obj.put(\"go\", \"테스트\"); PrintWriter out = response.getWriter(); out.write(callBack + \"(\" + obj.toString() + \")\"); System.out.println(callBack + \"(\" + obj.toString() + \")\"); out.flush(); out.close(); } 요청 json 에 callback 함수로 한번 감싸서 jsonp 구현하기 Client $.ajax({ url: \"/jsonp.json\", dataType: 'jsonp', jsonpCallback: \"myCallback\", success: function(data) { console.log('성공 - ', data); }, error: function(xhr) { console.log('실패 - ', xhr); } }); Server myCallback({\"message\":\"You got an AJAX response via JSONP from another site!\"}); jsonpCallback 옵션 없이 사용하기 Client $.ajax({ url: \"/jsonp.json\", dataType: 'jsonp', success: function(data) { console.log('성공 - ', data); }, error: function(xhr) { console.log('실패 - ', xhr); } }); Server jQuery18305806868467951786_1366340807385({\"key\":\"value\"}); jsonp 로 전달 받는 응답데이터는 다음과 같다. _callback_jsonp_({ \"code\": 1, \"message\": \"success\", \"result_set\": {} }); Info 전달 받는 데이터를 콜백 함수의 매개변수로 전달하여 실행 시키는 구조CORS 설정을 한다면 별도의 jsonp 작업은 필요 없다.요청 데이터의 응답 헤더가 Access-Control-Allow-Orign: * 으로 변경 암묵적 전역 자바스크립트 내에 변수 선언시에 선언자 (var) 가 없으면 암묵적 전역 으로 인해 전역 프로퍼티로 등록 된다. var a = 0; b = 2; (function () { c = 3; }()); delete a; delete b; delete c; console.log(typeof a); // number console.log(typeof b); // undefined console.log(typeof c); // undefined 프로퍼티는 delete 연산자로 삭제 가능 상속 (Inheritance) 프로토 타입을 이용한 확장 자바스크립트에는 자바와 달리 class 가 존재하지 않아 prototype 을 사용하여 class 를 구현합니다. 상속 Class 생성 Example #1 : JS - ES5 function Shape() { this.x = 0; this.y = 0; } Shape.prototype.move = function (x, y) { this.x += x; this.y += y; } function Rectangle() { Shape.call(this); } Rectangle.prototype = Object.create(Shape.prototype); Rectangle.prototype.constructor = Rectangle; 상속 객체 생성 Example #1 : JS - ES5 var rect = new Rectangle(); console.log(rect instanceof Rectangle); console.log(rect instanceof Shape); rect.move(1, 1); 프로토타입의 확장을 이용한 방법 은 Monkey Patching 이라고도 하며 권장하지 않는 방법 이다. Object.create() 를 이용한 메소드 상속 Example #1 : JS - ES5 var parent = { num: 2, increase: function () { return (this.num + 1); } } console.log(parent.increase()); // 3 var child = Object.create(parent); child.num = 12; console.log(child.increase()); // 13 자료형 (변수형) 에 대한 차이점 ES 5 & 6 에 지원하는 자료형 (변수형) var let const 은 다음과 같은 차이점을 가진다. var let const 유효범위 function scope block scope block scope 재할당 O O X 호이스팅 (Hoisting) 자바스크립트 엔진이 실행 컨텍스트를 생성하면서 scope 를 정의할 때 기술된 순서에 상관없이 선언부에 대한 처리 해석의 우선순위를 최우선으로 끌어올려 먼저 해석 하는 것이는 다음과 같은 특징을 갖는다. 변수의 정의가 그 범위에 따라 선언과 할당으로 분리 한다. 선언과 할당이 분리되며 에러를 야기시킬 수 있다. ES6 에서는 호이스팅의 지원이 없어졌다. (ES5 식의 호이스팅 / TDZ 관점) 기존 ES5 에서는 호이스팅이 있어 해당 값을 선언 후 호출하면 undefined 로 나온다. 예제 코드 Example #1 : JS - ES5 var value = 'outer scope'; (function () { console.log(value); // undefined var value = 'inner scope'; }); 위 코드는 아래와 같이 해석 된다. var value = 'outer scope'; (function () { var value; // undefined console.log(value); var value = 'inner scope'; }); var 에 비해 const/let 은 TDZ 에 의해서 ReferenceError 가 발생한다. const value = 'outer scope'; (function () { console.log(value); const value = 'inner scope'; }()); TDZ (Temporal Dead Zone) ? 초기화 (선언) 가 되지 않는 객체들을 참조 할 수 없다.(호이스팅이 되지 않는것은 아님 - ES5 처럼 undefined 로 선 할당이 안됨) 함수의 선언과 표현식 함수 선언식 (Function Declarations / Function Statement) 실행 가능한 상태가 아니며 함수의 정의를 나타내는 Statement 으로 코드 해석에 따른 수행 경과가 존재 하지 않는다. Example #1 : JS - ES5 // 함수 선언식 function foo() { /* statement */ } 함수 표현식 (Function Expressions / Function Literal) 실행 가능한 상태 코드 로 해석되어 지거나 혹은 변수나 데이터 구조에 할당 되어 있음을 의미한다. Example #1 : JS - ES5 // 함수 표현식 var foo = function () { /* statement */ } 함수의 선언식은 호이스팅에 영향 을 받지만, 함수의 표현식은 호이스팅에 영향을 받지 않는다. 익명 함수 (Anonymouse Function) 함수의 선언이 아닌 함수 표현식을 이용하는 방법 이며 즉시 실행 구문을 만들때 많이 사용된다. 익명 함수는 동적으로 할당되는 유효범위를 가지기 때문에 강제적인 유효범위를 설정 하는 경우에도 사용 된다. Example #1 : JS - ES5 (function () { var value = 'Hello World'; }()); console.log(value); // ReferenceError: value is not defined 즉시 실행 구문 (IIFE : Immediately-Invoked Function Expression) 익명 함수 (Anonymouse Function) 를 이용하여 바로 실행 가능한 함수 표현식을 이용 하여 만들어 내는 구문 Syntax (function () { /* 실행코드 */ }()); Example 기본적인 사용법 (function () { /* statement */ })(); (function () { /* statement */ }()); (() => { /* statement */ })(); // With ES6 arrow functions (though parentheses only allowed on outside) 다른 방식으로 실행을 강제하는 방법 !function () { /* statement */ }(); ~function () { /* statement */ }(); -function () { /* statement */ }(); +function () { /* statement */ }(); void function () { /* statement */ }(); 참고자료 https://en.wikipedia.org/wiki/Immediately_invoked_function_expression Strict Mode ECMA5 의 엄격모드는 다음과 같은 특징을 가집니다.이 구문은 전체 스크립트 문 혹은 부분 함수에 적용이 가능하다. ({} 로 묶은 블럭문에는 적용불가) Syntax 'use strict'; 특징 기존에는 무시되던 에러들을 Throwing 한다. 최적화 작업을 도와준다. (특정 스크립트 코드가 빨리 해석되게끔 함) 향후 버전에서 정의될 문법들을 금지한다. 참고자료 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Strict_mode "},"book/02.-front-end/03.-javascript/01.-general/design-pattern.html":{"url":"book/02.-front-end/03.-javascript/01.-general/design-pattern.html","title":"Design Pattern","keywords":"","body":"Design Pattern 네임스페이스 패턴 지역/전역 객체를 선언하여 그 안에 값을 삽입하여 사용하는 것 권장 패턴 var App = App || {}; App.Parent = function () {}; App.Child = function () {}; App.container = 1; App.module = { module_1: { data: {a: 1, b: 2} }, module_2: {} }; 안티 패턴 function Parent() {} function Child() {} var some_var = 1; var module1 = {}; module.data = {a : 1, b : 2}; var module2 = {} 모듈 패턴 기본 모듈 패턴 public 과 private 의 접근 권한을 가능하게 한다. (function () { // private 변수들과 함수들을 선언 return { // public 변수들과 함수들을 선언 }; }()); var HTMLChanger = (function() { var contents = 'contents'; var changeHTML = function () { var element = document.getElementById('attribute-to-change'); element.innerHTML = contents; } return { callChangeHTML: function () { changeHTML(); console.log(contents); } }; }()); HTMLChanger.callChangeHTML(); // 'contents' console.log(HTMLChanger.contents); // undefined 권장 모듈 패턴 Module Scope 내에서 사용할 변수 작성 Utility Method 작성 DOM 조작 메소드 작성 Event Handler 작성 Public Method 작성 var module = (function () { // 1. Module Scope 내에서 사용할 변수 작성 var scopeVal = {}, utilMethod, manipulateDOM, eventHandler, initModule; // 2. Utility Method 작성 utilMethod = function () { /* 실행 코드 */ }; // 3. DOM 조작 메소드 작성 manipulateDOM = function () { /* 실행 코드 */ } // 4. Event Handler 작성 eventHandler = function () { /* 실행 코드 */ } // 5. Public Method 작성 return { init: initMethod }; }()); 커링 여러개의 인자를 받는 함수가 있을 경우 일부의 인자만 받는 함수를 만드는 기법 Currying Example function volume(l, w, h) { return l * w * h; } function curry(fn) { var arity = fn.length; return (function resolver() { var memory = Array.prototype.slice.call(arguments); return function () { var local = memory.slice(); Array.prototype.push.apply(local, arguments); var next = (local.length >= arity? fn : resolver); return next.apply(null, local); }; }()); } Example #1 : JS - ES5 var curried = curry(volume), length = curried(2), lengthAndWidth = length(3); console.log(lengthAndWidth(4)); Example #2 : JS - ES5 var _curried = curry(volume); console.log(_curried(2)(3)(4)); Case 2 가 10배정도 빠름 메모이제이션 이전에 연산된 결과를 저장하고 사용하는 패턴메모리 상에 임시 저장값을 저장하여 사용할 수 있어 시간 복잡도를 많이 줄인다. 일반적인 피보나치 로직 var count = 0; var fibonacci = function (n) { count++; return n 메모이제이션을 사용한 피보나치 로직 1 var fibonacci = function () { var memo = [0, 1]; var count = 0; var fib = function (n) { count++; var result = meno[n]; if (typeof result !== 'number') { result = fib(n - 1) + fib(n - 2); memo[n] = result; } return result; }; return fib; } for (var i = 0; i 메모이제이션을 사용한 피보나치 로직 2 var factorial = (function () { var save = {}; var fact = function (number) { if (number > 0) { var saved = save[number - 1] || fact(number - 1); var result = number * saved; save[number] = result; console.log(saved, result); return result; } else { return 1; } } return fact; }()); factorial(7); "},"book/02.-front-end/03.-javascript/01.-general/web-api/":{"url":"book/02.-front-end/03.-javascript/01.-general/web-api/","title":"Web API","keywords":"","body":"Web API XMLHttpRequest 서버와의 비동기 데이터 통신을 하기 위해서 XMLHttpRequest 객체를 할 수 있다.기존의 자바스크립트의 ajax 을 사용하는 것과 동일하다. 1. HTTP Request 생성 모든 브라우저에서 사용 가능한 인스턴스를 생성한다. var xhr if (window.XMLHttpRequest) { xhr = new XMLHttpRequest(); } else if (window.ActiveXObject) { xhr = new ActiveXObject('Microsoft.XMLHTTP'); } 2. 응답 데이터를 처리할 callback 함수를 정의 var successCallback = function () { // 서버에서 받은 응답을 프로세싱 } xhr.onreadystatechange = successCallback; 3. 요청 (Request) 와 응답 (Response) 을 정의 xhr.open('GET', '/json', true); xhr.send(null); open Parameter method GET, POST, HEAD 대문자 로 표기하는 것을 권한다 (일부 브라우저에서는 비 동작할 수 있음) url 요청할 서버의 경로를 입력한다. async 수행 방식을 결정한다 (동기 / 비 동기) send Parameter POST 방식으로 요구 한 경우 서버로 보낼 데이터를 정의한다 json , soap 혹은 쿼리 스트링으로 표현 가능 POST 로 통신할 경우 요청 (request) MINE type을 설정 해야 합니다.예를 들면 send 를 호출하기 전에 아래와 같은 형태로 send 로 보낼 쿼리를 이용해야 한다. xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); 4. 응답 데이터 처리 데이터 요청 (request) 하였을때의 응답 (response) 처리를 해야 한다. 응답에 사용되는 callback 함수에서 XMLHttpRequest 객체는 readyState 다음과 같은 응답 요구 상태값을 가진다. readyState 가 가질 수 있는 응답 상태 값 0 (uninitialized) 객체가 막 생성되었다. open 메소드가 수행 되지 않았다. 1 (loading) send 메소드가 수행 되지 않았다. 2 (loaded) send 메소드가 수행 되었지만 요청 헤더를 사용할 수 없다. 3 (interactive) 일부 데이터만 수신한 상태이며, 상태 및 응답 헤더는 사용가능 요청 수행중 4 (complete) 요청한 데이터를 전부 받은 상태이다. 요청 및 응답이 완료됨 동일하게 XMLHttpRequest 객체는 state 다음과 같은 상태값을 가진다. 200 정상 403 권한 부족 혹은 접근 금지 404 페이지를 찾을 수 없음 var successCallback = function () { if (xhr.readState === 4 && xhr.status === 200) { console.log('Success'); } else { console.log('Failed'); } } 5. 최종 완료 코드 var xhr = new XMLHttpRequest(); xhr.open('GET', '/json', true); xhr.onreadystatechange = function (obj) { if (xhr.readyState === 4 && xhr.status === 200) { /* 성공 코드 */ var responseObj = JSON.stringify(xhr.responseText); } else { /* 실패 코드 */ } }; xhr.send(null); 프로그래스 모니터링 XMLHttpRequest 가 지원하는 nsIJSXMLHttpRequest 인터페이스는 요청이 처리되는 동안 발생되는 이벤트가 수신 가능하며 주기적인 진행상태 알림 및 에러 알림 등을 확인 가능 하다 var onProgress = function (e) { var percent = (e.position / e.totalSize) * 100; ... } var onError = function (e) { console.log('Error ', e.target.status, ' occurred while receving the document'); } ... var xhr = new XMLHttpRequest(); xhr.open('GET', '/json', true); xhr.onprogress = onProgress; xhr.onload = onLoad; xhr.onerror = onError; xhr.send(null); onprogress 의 속성인 position 과 totalSize 는 받은 데이터가 몇 바이트인지, 전체 데이터 크기가 몇 바이트인지 각각 나타냅니다. 모든 이벤트는 그에 대응하는 XMLHttpRequest 를 target 속성으로 가지고 있습니다. CORS 관련 설정 이슈 크로스 도메인간의 쿠키 설정은 되지 않기 때문에 정책 혹은 데이터 명세의 변경을 통해 해결한다. Request Header 혹은 Body 에 필요한 데이터를 추가하여 보내준다. $.ajax({ ... beforeSend: function (xhr) { xhr.setRequestHeader('param', $.cookie('value')); }, ... }) jQuery Ajax 사용시에는 다음과 같이 사용 $.ajax({ ... xhrFields: { withCredentials: true }, ... }) jQuery 1.5.1 에서 추가된 기능 으로 해당 하위 버전은 지원 불가 "},"book/02.-front-end/03.-javascript/01.-general/web-api/window.html":{"url":"book/02.-front-end/03.-javascript/01.-general/web-api/window.html","title":"Window","keywords":"","body":"Window SetTimeout WindowTimers 에서 지원하는 타이머 객체로서 자바스크립트 엔진이 일정시간 대기하였다가 UI 큐에 작업을 추가 한다. UI 큐에 추가한 작업은 이전에 추가된 작업 대기열 이후에 실행행 될 수 있도록 예정된다. Syntax [window.]setTimeout(callback[, delay[, param1[, ... paramN]]]); Parameter window this 객체가 window 일때 생략 가능 callback 지연된 시간이 끝난 후 실행되는 콜백 함수 delay 함수 지연 시간 (default : 0) param1 ... paramN 콜백 함수로 전달될 매개변수 IE9 이하에서는 매개변수 전달이 안된다. (IE 10 이상 지원) Example #1 : JS - ES5 var timeoutId; // 타이머 세팅 function setTimer() { timeoutId = window.setTimeout(function () { alert('Notice'); }, 2000); } // 타이머 삭제 function cancleTimer() { window.clearTimeout(timeoutId); } 지정된 시간 이후에 UI 작업 큐에 추가되기 때문에 실제로 언제 실행 되는지는 알 수 없다. SetInterval 일정한 주기를 기간으로 callback 함수를 호출 합니다. Syntax [window.]setInterval(callback, delay[, param1[, ... paramN]]); Parameter window this 객체가 window 일때 생략 가능 callback 지연된 시간이 끝난 후 실행되는 콜백 함수 delay 함수 지연 시간 (default : 0) param1 ... paramN 콜백 함수로 전달될 매개변수 IE9 이하에서는 매개변수 전달이 안된다. (IE 10 이상 지원) Example var intervalID; // 타이머 세팅 function setTimer() { intervalId = window.setInterval(function () { alert('Notice'); }, 2000); } // 타이머 삭제 function cancleTimer() { window.clearInterval(intervalId); } RequestAnimationFrame 브라우저에게 callback 함수를 (프레임 단위로 처리되는) 호출 하도록 합니다.이 callback 은 보통 1초에 60회 정도 호출되게 설계되어 있지만W3C 권장사항에 따라 디스플레이의 주사율과 일치하도록 실행 됩니다. 에서는 requestAnimationFrame() 의 호출이 멈출수 있습니다. Syntax [window.]requestAnimationFrame(callback); Polyfill 브라우저 별로 다를 수가 있으니 아래 구문으로 사용을 권한다. const reqAnimate = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || ((callback) => { window.setTimeout(callback, 1000 / 60); }); reqAnimate(() => { /* statement */ }); "},"book/02.-front-end/03.-javascript/01.-general/web-api/dom.html":{"url":"book/02.-front-end/03.-javascript/01.-general/web-api/dom.html","title":"DOM","keywords":"","body":"DOM DOM (Document Object Model : 문서 객체 모델) 은 스크립트와 같은 프로그래밍 언어를 웹 페이지에 연결하는 역활을 한다. "},"book/02.-front-end/03.-javascript/01.-general/web-api/element.html":{"url":"book/02.-front-end/03.-javascript/01.-general/web-api/element.html","title":"Element","keywords":"","body":"Element getBoundingClientRect 요소의 크기와 요소의 viewport 에서의 상대적인 위치 정보를 가져옵니다. Syntax var domRect = element.getBoundingClientRect(); 참고자료 https://developer.mozilla.org/ko/docs/Web/API/Element/getBoundingClientRect "},"book/02.-front-end/03.-javascript/02.-references/":{"url":"book/02.-front-end/03.-javascript/02.-references/","title":"02. References","summary":"표준 내장 객체","keywords":"","body":"02. References "},"book/02.-front-end/03.-javascript/02.-references/built-in-object/":{"url":"book/02.-front-end/03.-javascript/02.-references/built-in-object/","title":"Built-in Object","summary":"자바스크립트의 함수 객체를 정의합니다.","keywords":"","body":"Built-in Object "},"book/02.-front-end/03.-javascript/02.-references/built-in-object/array.html":{"url":"book/02.-front-end/03.-javascript/02.-references/built-in-object/array.html","title":"Array","keywords":"","body":"Array concat Description concat 메서드는 인자로 주어진 배열이나 값들을 기존 배열에 합쳐서 새로운 배열을 반환 합니다. Syntax arrayObj1.concat(arrayObj2) Parameter arrayObj1, arrayObj2 Array 객체 Example ['H', 'e', 'l', 'l', 'o'].concat(['W', 'o', 'r', 'l', 'd']); // ['H', 'e', 'l', 'l', 'o', 'W', 'o', 'r', 'l', 'd'] 이 메소드는 새로운 배열 객체를 반환 합니다. slice Description 특정 배열의 start 와 end 인덱스의 새로운 배열 객체를 반환 합니다. Syntax arrayObj.slice(start, [end]) Parameter arrayObj Array 객체 start arrayObject 에 대한 지정된 부분의 시작 end arrayObject 에 대한 지정된 부분의 끝 Example ['H', 'e', 'l', 'l', 'o'].slice(1) // ['e', 'l', 'l', 'o'] ['H', 'e', 'l', 'l', 'o'].slice(1, 4) // ['e', 'l', 'l'] ['H', 'e', 'l', 'l', 'o'].slice(0, -1) // ['H', 'e', 'l', 'l'] ['H', 'e', 'l', 'l', 'o'].slice(-1, 0) // [] 이 메소드는 새로운 배열 객체를 반환 합니다. shift Description 배열의 첫번째 요소를 제거하고, 제거된 요소를 반환합니다. Syntax arrayObj.shift() Example var arrayObj = ['H', 'e', 'l', 'l', 'o']; var shifted = arrayObj.shift(); console.log(shifted); // 'H' console.log(arrayObj); // ['e', 'l', 'l', 'o'] while 구문 수행시 첫번째 요소를 제거하면서 빈 배열이 나올때까지 반복문을 수행한다. var names = [\"Andrew\", \"Edward\", \"Paul\", \"Chris\" ,\"John\"]; while( (i = names.shift()) !== undefined ) { console.log(i); } // Andrew, Edward, Paul, Chris, John 이 메소드는 배열의 길이를 변하게 합니다. 배열의 마지막 요소를 제거하는건 pop 메소드 이다. unshift Description 새로운 요소를 배열의 앞쪽에 추가한다.return 값은 새로운 요소가 추가된 배열이다. Syntax arrayObj.unshift([element1[, ...[, elementN]]]) Example var arrayObj = ['1', '2']; arrayObj.unshift(0); // arr is [0, 1, 2] arrayObj.unshift(-2, -1); // arr is [-2, -1, 0, 1, 2] arrayObj.unshift([-3]); // arr is [[-3], -2, -1, 0, 1, 2] 이 메소드는 배열의 길이를 변하게 합니다. map Description map() 메소드는 배열내의 모든 요소에 대하여 제공된 함수(callback)를 호출하고, 그 결과를 모아서 새로운 배열을 반환 합니다. Syntax var newAry = arrayObj.map(function callback(currentValue[, index[, array]]) { // newAry 의 새 요소를 반환 }[, thisArg]); Parameter callback 새로운 배열 요소를 생성하는 함수 currentValue 배열 요소 중 현재 처리되고 있는 요소 index 현재 처리되는 요소의 배열 내 인덱스 array map 메소드가 적용되는 본래의 배열 thisArg callback을 실행할 때 this로 사용되는 값 (기본값은 window 객체) Example var numbers = [1, 4, 9]; var roots = numbers.map(Math.sqrt); console.log(numbers); // [1, 4, 9] console.log(roots); // [1, 2, 3] var numbers = [1, 4, 9]; var doubles = numbers.map(function (num) { return num * 2; }); console.log(doubles); // [2, 8, 18] var mapAry = [{key: 1, value, 10}, {key: 2, value: 20}, {key: 3, value: 30}]; var new_mapAry = mapAry.map(function (obj) { var new_obj = {} new_obj[obj.key] = obj.value; return new_obj; }); console.log(new_mapAry); // [{1:10}, {2:20}, {3:30}] 지정된 사이즈로 임의의 배열 생성 var SIZE = 10; var getRandomNumber = function (min, max, floor) { /* 랜덤 값 제조 */ }; var newArray = Array .apply(null, {length: SIZE}) .map(Function.call, function () { return getRandomNumber(MIN, MAX) }); 이 메소드는 새로운 배열 객체를 반환 합니다. filter Description filter() 메소드는 배열내의 모든 요소에 대하여 제공된 테스트 함수(callback)를 호출하고, 그 결과를 모아서 새로운 배열을 반환 합니다. Syntax var newAry = arrayObj.filter(function callback(currentValue[, index[, array]]) { // 반환형이 boolean 값 true 이면 값이 유지, false 이면 값 삭제 }[, thisArg]); Parameter callback 새로운 배열 요소를 생성하는 함수 currentValue 배열 요소 중 현재 처리되고 있는 요소 index 현재 처리되는 요소의 배열 내 인덱스 array map 메소드가 적용되는 본래의 배열 thisArg callback을 실행할 때 this로 사용되는 값 (기본값은 window 객체) Example function isBigEnough(value) { return value >= 10; } var filterd = [12, 5, 8, 130, 44].filter(isBigEnough); console.log(filtered); // [12, 130, 44] 이 메소드는 새로운 배열 객체를 반환 합니다. forEach Description forEach() 메소드는 배열 요소마다 한 번씩 제공된 함수(callback) 함수를 호출해서 사용합니다. Syntax arrayObj.forEach(function callback(currentValue[, index[, array]]) { // 반환형 없이 각 요소마다 함수를 실행 }[, thisArg]); Parameter callback 새로운 배열 요소를 생성하는 함수 currentValue 배열 요소 중 현재 처리되고 있는 요소 index 현재 처리되는 요소의 배열 내 인덱스 array map 메소드가 적용되는 본래의 배열 thisArg callback을 실행할 때 this로 사용되는 값 (기본값은 window 객체) sort Description sort() 메서드는 배열의 요소를 적절한 위치에 정렬하고 배열을 반환합니다.기본 정렬 순서는 유니 코드 포인트에 따릅니다. Syntax arrayObj.sort([compareFunction]) Parameter compareFunction 정렬 순서를 정의하는 함수를 지정합니다. (미 지정시 기본 정렬 순서에 따름) Example var fruit = ['orange', 'apple', 'banana']; console.log(fruit.sort()); // ['apple', 'banana', 'orange'] var score = [4, 11, 2, 10, 3, 1]; // ASCII 문자 순서로 정렬되어 숫자의 크기대로 나오지 않음 // [1, 10, 11, 2, 3, 4] score.sort(); // 오름차순 정렬 // [1, 2, 3, 4, 10, 11] score.sort(function () { return a - b; }); // 내림차순 정렬 // [11, 10, 4, 3, 2, 1] score.sort(function () { return b - a; }); var student = { { name: 'Edward', value: 21 }, { name: 'Sharpe', value: 37 }, { name: 'And', value: 45 }, { name: 'The', value: -12 }, { name: 'Magnetic' }, { name: 'Zeros', value: 37 } }; // value 기준으로 정렬 student.sort(function (a, b) { if (a.value > b.value) { return 1; } if (a.value nameB) { return 1; } // 이름이 같을 경우 return 0; }); 기존순서는 그대로 두고 중복 제거 var names = [\"Mike\",\"Matt\",\"Nancy\",\"Adam\",\"Jenny\",\"Nancy\",\"Carl\"]; var uniq = names.reduce(function (a, b){ if (a.indexOf(b) 기존순서는 그대로 두고 중복 제거 var uniq = names.slice() // 정렬하기 전에 복사본을 만든다. .sort(function (a, b){ return a - b; }) .reduce(function (a, b){ if (a.slice(-1)[0] !== b) a.push(b); // slice(-1)[0] 을 통해 마지막 아이템을 가져온다. return a; },[]); //a가 시작될 때를 위한 비어있는 배열 // 한 줄로 표현 return names.slice().sort(function(a,b){return a - b}).reduce(function(a,b){if (a.slice(-1)[0] !== b) a.push(b);return a;},[]); indexOf Description indexOf 메서드는 배열에서 지정된 요소를 찾을 수있는 첫 번째 인덱스를 반환하고 존재하지 않으면 -1을 반환합니다. Syntax arrayObj.indexOf(element) Parameter arrayObj 배열 객체 element 찾을 요소 Example var a = [2, 9, 9]; a.indexOf(2); // 0 a.indexOf(7); // -1 if (a.indexOf(7) === -1) { // 요소가 배열에 존재하지 않습니다. } Polyfill IE 8 이하 지원 안함 var indexOf = Array.prototype.indexOf || (function (prop, s) { for (var i = (s || 0); i if (indexOf.call(arrayObj, value) > -1) { console.log('value is contain'); } else { console.log('value is not contain'); } "},"book/02.-front-end/03.-javascript/02.-references/built-in-object/object.html":{"url":"book/02.-front-end/03.-javascript/02.-references/built-in-object/object.html","title":"Object","keywords":"","body":"Object Object Keys Length Description object 타입의 데이터 중에 키의 갯수를 구한다. Syntax Object.keys(obj).length Example #1 : JS - ES5 var obj = {a: 1, b: 2: c: 3}; var size = Object.keys(obj).length; console.log(size); // 3 assign Description assign() 메소드는 열거할 수 있는 하나의 이상의 소스 오브젝트의 프로퍼티들을 복사합니다. Syntax Object.assign(target [, sources]) Parameter target 타겟 오브젝트 sources 하나 이상의 소스 오브젝트 Example var obj = {a: 1}; var cp_obj = Object.assign({}, obj); console.log(cp_obj); // {a: 1} var obj1 = { a: 1 }; var obj2 = { b: 2 }; var obj3 = { c: 3 }; var obj = Object.assign(o1, o2, o3); console.log(obj); // { a: 1, b: 2, c: 3 } console.log(obj1); // { a: 1, b: 2, c: 3 }, 타겟 오브젝트, 그 자체도 변화합니다. var obj1 = { a: 1, b: 1, c: 1 }; var obj2 = { b: 2, c: 2 }; var obj3 = { c: 3 }; var obj = Object.assign({}, obj1, obj2, obj3); console.log(obj); // { a: 1, b: 2, c: 3 } Polyfill if (typeof Object.assign != 'function') { (function () { Object.assign = function (target) { 'use strict'; if (target === undefined || target === null) { throw new TypeError('Cannot convert undefined or null to object'); } var output = Object(target); for (var index = 1; index hasOwnProperty Description hasOwnProperty() 메소드는 객체가 특정 프로퍼티를 가지고 있는지 확인 합니다. Syntax Object.hasOwnProperty(prop) Parameter prop 확인 하려는 프로퍼티 명칭 Example var obj = new Object(); obj.prop = 'exists'; obj.hasOwnProperty('prop'); // true delete obj.prop(); obj.hasOwnProperty('prop'); // false var obj = new Object(); obj.prop = 'exists'; obj.hasOwnProperty('prop'); // true // 상속된 프로퍼티는 검사할 수 없다. obj.hasOwnProperty('toString'); // false obj.hasOwnProperty('hasOwnProperty'); // false var obj = { hasOwnProperty: function() { return false; }, bar: 'Here be dragons' }; foo.hasOwnProperty('bar'); // false ({}).hasOwnProperty.call(foo, 'bar'); // true Object.prototype.hasOwnProperty.call(foo, 'bar'); // true "},"book/02.-front-end/03.-javascript/02.-references/built-in-object/function.html":{"url":"book/02.-front-end/03.-javascript/02.-references/built-in-object/function.html","title":"Function","keywords":"","body":"Function bind Description bind() 메소드는 호출될 때 그 this 키워드를 제공한 값으로 설정하고 새로운 함수를 생성합니다.실행하지 않고 함수만 반환 한다. Syntax func.bind(thisArg[, arg1[, arg2[, ... ]]]; Parameters thisArg 바인딩된 함수가 호출될 때 대상함수에 this 매개변수로서 전달되는 값 arg1, arg2, ... 대상 함수를 호출할 때 바인딩된 함수에 제공되는 인수 Retrun Value 지정된 this 값 및 초기 인수가 있는 주어진 함수의 복제본 call Description call() 메소드는 호출될 때 제공된 this 키워드 값과 인수를 함께 호출합니다. Syntax func.call(thisArg[, arg1[, arg2[, ... ]]]; Parameters thisArg 바인딩된 함수가 호출될 때 대상함수에 this 매개변수로서 전달되는 값 arg1, arg2, ... 대상 함수를 호출할 때 바인딩된 함수에 제공되는 인수 apply Description apply() 메소드는 호출될 때 제공된 this 키워드 값과 인수를 함께 호출합니다. Syntax func.call(thisArg, [argsArray]; Parameters thisArg 바인딩된 함수가 호출될 때 대상함수에 this 매개변수로서 전달되는 값 argsArray 대상 함수를 호출할 때 바인딩된 함수에 제공되는 인수의 배열 addEventListener Description 이벤트 타겟에서 사용할 리스너를 등록합니다. Syntax target.addEventListener(type, listener [, useCapture]); Parameter type 등록할 이벤트 타입 click mousedown mouseup keyup keydown keypress 등등... listener 특정 타입의 이벤트가 발생할 때 받을 객체 반드시 function 타입 useCapture 이벤트 캡쳐링/버블링 유무 참고자료 http://sculove.github.io/blog/2016/12/29/addEventListener-passive/ "},"book/02.-front-end/03.-javascript/02.-references/built-in-object/promise.html":{"url":"book/02.-front-end/03.-javascript/02.-references/built-in-object/promise.html","title":"Promise","keywords":"","body":"Promise JavaScript 특성상 싱글 스레드 환경에서 대부분의 작업들은 비동기로 이루어진다. 하지만 최근에 자바스크립트 기술의 발전과 하나의 작업을 콜백으로 결과를 받은뒤 순차적으로 작업을 수행하고자 한다면 아래와 같은 콜백 중첩 (콜백 지옥) 을 경험하게 된다. async(1, function () { async(2, function () { async(3, function () { async(4, function () { async(5, function () { console.log('작업 완료???!!??!!') }); }); }); }); }); 이러한 상황을 극복하기 위해 오래전부터 Promies 라는 패턴이 제안되어 왔으며 다양한 라이브러리를 통해서 이를 구현하여 사용해 왔다. Promise 패턴은 ES5 환경에서 일부 브라우저에서 사용 가능하며 ES6 에 정식 스팩에 포함되었다. 브라우저별 지원 여부 IE 는 사용 불가하여 Polyfill 코드를 사용하여 구현해야 함Chrome, FF 는 Full Support 아래는 HTML5Rocks 에서 보이고 있는 프로미스의 예제 이다. asyncThing1() .then( () => asyncThing2() ) .then( () => asyncThing3() ) .catch( error => asyncRecovery1() ) then( () => asyncThing4(), () => asyncRecovery2() ) .catch( error => console.log('Don\\'t worry about it') ) then( () => console.log('All done') ); 사용 Syntax new Promise(function (resolve, reject) { /* statement */ }); 실행시 Promise 구문에서 실행한 익명함수의 반환값은 무시된다. Parameters resolve 성공시 전달되는 인수 (함수 혹은 변수) reject 실패시 전달되는 인수 (함수 혹은 변수) Example Case 1 : 기초 Promise 의 기본적인 선언은 아래와 같다. var _promise = function (param) { return new Promise(function (resolve, reject) { window.setTimeout(function () { if (param) { resolve('Success'); } else { reject(Error('Failed')); } }, 3000); }); } Promise 사용시 다음 상태중에 하나가 될 것이다. pending 아직 Promise 를 수행중인 상태 fulfilled Promise 가 성공적인 상태이다. rejected Promise 가 실패한 상태이다. settled Promise 성공여부와 상관없이 완료된 상태이다. new Promise 로 Promise 가 생성되는 직후부터 resolve 나 reject 가 호출되기 전까지의 순간을 pending 상태라고 볼 수 있다.이후 비동기 작업이 마친뒤 결과물을 약속대로 잘 줄 수 있다면 첫번째 파라메터로 주입되는 resolve 함수를 호출하고, 실패했다면 reject 함수를 호출하는 것이 기본적인 Promise 개념이다. 이를 실행하는 실행부는 아래와 같다. _promise(true) .then(function (message) { console.log(message); }, function (error) { console.error(error); }); 실행부에서는 _promise() 를 실행하면 Promise 의 새로운 객체가 반환되고 정상적으로 비동기 작업이 수행됬을때 then 을 호출하는 API 가 존재한다.then 은 성공시 첫번째 파라메터를 수행하며, 실패시 두번째 파라메터를 수행하게 된다. Case 2 : 예외처리 Javascript 함수의 체이닝으로 연결된 형태에서 비동기 작업이 중간에 에러날 경우 다음과 같이 처리 가능하다. _promise(true) .then(JSON.parse) .catch(function () { alert('Error'); }) .then(function (message) { console.log(message); }) Case 3 : 모든 Promise 를 완료하고 실행 var promise1 = new Promise(function (resolve, reject) { window.setTimeout(function () { console.log('1st Promise'); resolve('1'); }, Math.random() * 20000 + 1000); }); var promise2 = new Promise(function (resolve, reject) { window.setTimeout(function () { console.log('2nd Promise'); resolve('2'); }, Math.random() * 10000 + 1000); }); Promise.all([promise1, promise2]) .then(function (values) { console.log('All Complete'); console.dir(values); }); async 와 await ES8 에서 Promise 사용을 쉽게 해주는 async 와 await 을 도입 하였다. async 비동기 함수를 정의하며 AsyncFunction 객체를 반환 합니다. AsyncFunction 객체는 해당 함수내에 포함되어 있는 코드를 수행하는 비동기 함수를 나타냅니다. await async 함수 내에서만 사용될 수 있으며 동기적으로 Promise 를 처리 해줍니다. async 밖에서 프로미스를 사용하면 then 콜백을 사용해야 한다. async function loadData() { var promise1 = req('/getData_1.json'); var promise2 = req('/getData_2.json'); var response1 = await promise1; var response2 = await promise2; return response1 + response2; } loadData() .then(() => { console.log('Done'); }); 참고자료 https://programmingsummaries.tistory.com/325 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise https://joshua1988.github.io/web-development/javascript/promise-for-beginners/ "},"book/02.-front-end/03.-javascript/02.-references/operator-and-expression.html":{"url":"book/02.-front-end/03.-javascript/02.-references/operator-and-expression.html","title":"Operator & Expression","keywords":"","body":"Operator & Expression in Description in 연산자는 명시된 속성이 객체에 존재하면 true 를 반환합니다. Syntax 속성 in 객체명 Parameters 속성 속성의 이름이나 배열의 인덱스를 뜻하는 문자열 또는 수의 값입니다. 객체명 객체의 명칭 Example var arrayObj = ['a', 'b', 'c']; console.log(3 in arrayObj); // false console.log(0 in arrayObj); // true console.log('a' in arrayObj); // false console.log('length' in arrayObj); // true var color1 = new String('green'); console.log('length' in color1); // true var color2 = 'Red'; console.log('length' in color2); // false // color2 는 String 객체가 아니기 때문에 오류를 발생함 String 생성자로 만들어진 문자열을 명시할 수 있지만 문자열 리터럴은 명시할 수 없다 console.log('toString' in {}); // true 프로토타입 체인에 의하여 접근 가능한 속성은 true 를 반환합니다. instanceof Description instanceof 연산자는 생성자의 prototype 속성과 묶인 프로토타입을 가진 오브젝트인지 확인합니다. Syntax object instanceof constructor Parameters object 테스트 대상인 오브젝트 constructor 테스트할 함수 (프로토타입 오브젝트) Example function C() {}; var obj = new C(); console.log(obj instanceof C); // true function Car(make, model, year) { this.make = make; this.model = model; this.year = year; } var auto = new Car('Honda', 'Accord', 1998); console.log(auto instanceof Car); // true console.log(auto instanceof Object); // true typeof Description typeof 연산자는 피연산자 타입을 가르키는 문자열을 반환합니다. 타입 결과 Undefined \"undefined\" Null \"object\" String \"string\" Number \"number\" Array \"object\" Boolean \"boolean\" Function Object \"function\" other Object \"object\" Syntax typeof 피연산자 Example console.log(typeof 100) // number console.log(typeof '100') // string console.log(typeof 'abc') // string console.log(typeof []) // object console.log(typeof undefined) // number console.log(typeof function foo() {}) // function delete Description delete 연산자는 오브젝트의 속성을 삭제한다. Syntax delete object[.property] Parameters object 오브젝트의 이름 또는 오브젝트의 표현식 property 삭제하고자 하는 속성 Example var Employee = { age: 28, name: 'abc' designation: 'developer' }; console.log(delete Employee.name); // true console.log(delete Employee.age); // true // 해당 프로퍼티가 존재하지 않아 true를 리턴합니다. console.log(delete Employee.salary); // true delete연산자의 사용시 유의사항. 존재하지 않는 속성을 삭제하려고 하면 아무 작업 없이 true를 반환 오브젝트에 프로토타입 체인과 같은 속성이 있다면 delete로 삭제 후에 프로토타입 체인 프로퍼티 사용가능 var로 선언된 프로퍼티는 삭제 불가 "},"book/02.-front-end/03.-javascript/02.-references/global-object.html":{"url":"book/02.-front-end/03.-javascript/02.-references/global-object.html","title":"Global Object","keywords":"","body":"Global Object Null 변수를 선언하고 null 객체를 삽입한 상태 (객체의 참조 연결이 해지된 것)자료형은 object 로 분류됨 console.log(typeof null); // \"object\" Undefined 변수 선언만 하고 값을 할당하지 않는 상태 (정의가 되지 않는 변수)자료형이 결정되지 않는 상태 "},"book/02.-front-end/03.-javascript/02.-references/ecma6/":{"url":"book/02.-front-end/03.-javascript/02.-references/ecma6/","title":"ECMA 6","keywords":"","body":"ECMA 6 ECMA 산하 Task Group 중에 하나의 ECMA-262 (TC39) 에서 유지 및 개선관리 되는 부분이다.ECMA Script 와 호환 및 확장되는 라이브러리 표준의 개발이다.ISO 및 IEC JTC 등의 표준을 게시한다. ECMAScript 6번째 표준 에디션 으로 많은 부분이 개선 및 추가 되었다. Function 기존 함수 선언식 (ES5) 에서 변경된 점 Example #1 : ES5 function foo() { /* statement */ } Example #2 : ES6 var obj = { foo() { /* statement */ }, poo: () => { /* statement */ } } obj.foo 과 obj.poo 는 동일한 기능을 한다. Arrows 화살표 함수 표현식은 축약형 함수 입니다. Syntax (param1, param2, ... , paramN) => { statements } Parameters statements 함수의 내용 Example #1 : ES6 // 매개변수가 하나 이상있는 경우는 괄호가 필요 (param1, param2) => { return param1 + param2 }; // 매개변수가 하나인 경우에는 괄호가 필요 없음 param1 => { return param1 + 1 } // 매개변수가 없을경우 () => { console.log('Hello World'); } Example #2 : ES6 var list = [2, 4, 6, 8]; // Expression Block 사용 안함 (표현식의 결과가 반환됨) var odd = list.map(value => value + 1); // [3, 5, 7, 9] // Expression Block 사용 (블럭 내부만 실행, 반환값을 위해서는 return 표현식을 명시해야 함) list.forEach(v => { console.log(v); }); Example #3 : ES6 // 객체 리터럴 반환 var func = () => ({ foo: 1 }); console.log(func()); // {foo: 1} Expression 선언 컨텍스트의 밖의 this 값을 가진다. this 가 바인딩 되지 않는다. function foo() { this.value = 0; setInterval(() => { console.log(this.value); // 0 }, 1000); } 생성자 (constructor) 로 사용될수 없다. (new 연산자 사용 불가) var Foo = () => {}; var foo = new Foo(); // TypeError : Foo is not a constructor Default Parameter Description 함수의 매개변수의 기본값이 설정 가능합니다. Syntax function func_name([param1[= defaultValue1][, ... , paramN[= defaultValueN]]]) { statements } Parameters func_name 함수명 param1, param2 파라메터 명 defaultValue1, defaultValue2 파라메터 기본값 statements 함수의 내용 Example #1 : ES6 function add(a, b = 1) { return a * b; } console.log(add(5)) // 5 Expression 함수에도 적용 가능하다. function callLog(msg = defaultMsg()) { return console.log(mes); } function defaultMsg() { return 'TEST_LOG'; } callLog() // TEST_LOG undefined 전달 시 function callLog(msg = 'TEST_LOG') { return console.log(mes); } callLog(undefined) // TEST_LOG Spread Operator 2개 이상의 인수를 나열하는 방식 Syntax // 함수 호출용 myFunction(...args); // 배열 리터럴용 [...args, 5, 6, 7]; // 비 구조화용 [a, b, ...args] = [1, 2, 3, 4, 5]; Example var org = [3, 4]; var custom = [1, 2, ...org, 5]; // [1, 2, 3, 4, 5] Expression 스프레드 연산자로 배열 & 객체 복제. var array = [1, 2, 3]; var cloneArray = [...array]; console.log(cloneArray); // [1, 2, 3] var obj = {a: 10, b: 20}; var cloneObj = {...obj}; console.log(cloneObj); // {a: 10, b: 20} Rest Parameter 나머지 매개변수 (rest parameter) 구문에 나머지 인수들도 정의해 나타냅니다. Syntax function (a, b, ...theArgs) { // statements } Example function foo(...Args) { console.log(Args.length); } foo(); // 0 foo(5); // 2 foo(5, 7, 9); // 3 function foo(arg1, ...Args) { return Args.map(function (elem) { return arg1 * elem }); } console.log(foo(2, 1, 2, 3)); // [2, 4, 6] Expression arguments 객체가 아닌 Array 객체의 method 사용이 가능하다. function sortRestArgs(...Args) { return Args.sort(); } function sortArguments() { return arguments.sort(); } console.log(sortRestArgs(5, 3, 7, 1)); // [1, 3, 5, 7] console.log(sortArguments(5, 3, 7, 1)); // TypeError Destructuring Syntax 구조분해 문법은 ES6 에서 사용되는 변수의 선언 방식입니다. Expression 특정 객체의 값을 꺼내오는 방법 var josh = { language: 'javascript', position: 'front-end', area: 'pangyo', hobby: 'singing', age: '102' }; var language = josh.language; var position = josh.position; var area = josh.area; var hobby = josh.hobby; var age = josh.age; var josh = { language: 'javascript', position: 'front-end', area: 'pangyo', hobby: 'singing', age: '102' }; var { language, position, area, hobby, age } = josh; console.log(language); // javascript console.log(position); // front-end console.log(area); // pangyo console.log(hobby); // singing console.log(age); // 102 함수의 적용 var context = { commit: actionName => console.log(actionName + ' has been committed!!') }; var {commit} = context; commit('addProducts'); // addProducts has been committed !! Export Syntax 지정된 파일에서 객체 (함수, 오브젝트, 원시타입) 을 export 하는데 사용된다. Syntax // Named Exports export { myFunction }; // 함수 exports export const foo = Math.sqrt(2); // 상수 exports // Default Exports (스크립트에서 유일하게 한번 사용) export default myFunctionOrClass; 참고자료 http://sanghaklee.tistory.com/54 "},"book/02.-front-end/03.-javascript/02.-references/ecma6/symbol.html":{"url":"book/02.-front-end/03.-javascript/02.-references/ecma6/symbol.html","title":"Symbol","keywords":"","body":"Symbol ES6 에서 나온 원시 데이터형 (Primitive DataType) 의 일종으로 객체에 Unique 한 속성을 만들어 다른 라이브러리와 충동을 피하기 위함이다. Undefined Null Boolean Number String Object Symbol Syntax Symbol([description]); Parameter description 선택적 (Optional) 문자열로 디버깅에 사용할 수 있는 설명이다. 자체적으로 심볼에 접근하는 용도로 사용할 수 없음 Description 기본적으로 새 원시 심볼을 생성하려면 아래와 같이 선택적 문자열과 함께 Symbol() 을 쓰면 된다. var sym1 = Symbol(); var sym2 = Symbol('foo'); var sym3 = Symbol('foo'); 매번 새로운 심볼을 생성하기 때문에 아래 같이은 조건은 성립할 수 없다. console.log(Symbol('foo') === Symbol('foo')) // false new 연산자를 이용한 문법은 TypeError 를 발생한다. var sym = new Symbol(); // TypeError 반드시 심볼 래퍼 객체 생성이 필요하면 Object() 함수를 이용하여 사용가능하다. var sym = Symbol('foo'); typeof sym; // \"symbol\" var symObj = Object(sym); typeof symObj; // \"object\" 심볼의 생성 심볼의 생성은 다음 3가지 방법이 있다. 고유한 심볼 생성 var sym = Symbol('foo'); 심볼 레지스트리에서 찾아서 복사 var sym = Symbol.for('foo'); 미리 정의된 상용 심볼 사용 Symbol.iterator 상용심볼은 특별한 용도를 위해서 만들어 놓은 심볼이며 대표적인 상용 심볼은 다음과 같다. Symbol.iterator 이터러블한 객체를 정의하기 위한 심볼 Symbol.hasInstance instanceof 를 확장하기 위한 심볼 Symbol.match String.prototype.match 메소드의 확장 "},"book/02.-front-end/03.-javascript/02.-references/ecma6/iterator.html":{"url":"book/02.-front-end/03.-javascript/02.-references/ecma6/iterator.html","title":"Iterator","keywords":"","body":"Iterable & Iterator 자바스크립트의 반복문의 for loop 는 다음 몇가지로 나뉜다. for 가장 기본적인 for loop forEach 배열을 순회하며 value 와 index 를 매개변수로 전달한다. break, return 으로 루프를 중단할 수 없다. for in 배열의 인덱스만 순환 하는것이 아닌 프로토타입 체인을 포함한 모든 속성을 순회한다. 배열보다는 객체를 순회 하기 위해 만들어진 루프이다. for of for in 으로 배열을 순회할 때 생기는 문제점들을 해소하였다. for of 는 순회가능한 (iterable) 객체를 상대로 사용 가능 하다. 순회가능한 (Iterable) 한 객체는 Symbol.iterator 심볼을 속성으로 가지고 있으며 이터레이터 객체를 반환하는 객체 를 뜻한다.해당 스팩을 이터러블 프로토콜 이라고 하며 해당 스팩을 구현한 객체를 이터러블 객체 라고 한다. Iterator Interface TC39 에서 정의한 Iterator Interface 정의를 따른 Object 로써 내응은 다음과 같다. Iterator Interface next 라는 키를 갖고 있으며 값으로 인자를 받지 않고 Iterator Result Object 를 반환하는 함수가 온다. Iterator Result Object 는 value 와 done 이라는 키를 갖고 있다. value 는 실제 값을 의미 done 는 계속 반복 할 수 있는지 따른 boolean 값 영원히 0 을 반환하는 Iterator { next: function () { return { value: 0, done: false }; } } 각 배열을 순회하며 배열의 끝 값을 반환하는 Iterator { data: [1, 2, 3, 4] next: function () { return { done: this.data.length === 0, value: this.data.pop() }; } } ECMA6 에서는 객체 리터럴 작성 순서에 따라 파싱 한다. 예를 들면 위 코드의 done 과 value 중에서 done 이 먼저 작성되어 있기 때문에 done 을 먼저 파싱한다.ECMA5 에서는 done 이든 value 든 어느것을 먼저 파싱할지 보장이 안됨 Iterable Object Symbol.iterator 의 키를 가지고 있는 객체로써 다음 스펙을 구현한 객체이다. Iterable Spec Symbol.iterator 의 키를 갖고 있다. 값으로 인자를 받지 않고 Iterator Object 를 반환하는 함수가 온다. { [Symbol.iterator]: function () { return { next: function { return { value: 1, done: false }; } }; } } 참고자료 ECMA-262 - Iterable InterfaceGDG 2016 발표자료GDG DevFest Seoul 2016 - Iterable & Iterator "},"book/02.-front-end/03.-javascript/02.-references/ecma6/generator.html":{"url":"book/02.-front-end/03.-javascript/02.-references/ecma6/generator.html","title":"Generator","keywords":"","body":"Generator Iterator Interface 를 구현한 확장형 함수 Example #1 - ES6 function* foo() { yield '첫번째 호출'; yield '두번째 호출'; yield '세번째 호출'; yield '네번째 호출'; } var _foo = foo(); for (var i = 0; i 네번째 까지만 정상 로그가 찍히며 이후로는 { value: undefined, done: false } 로 나온다. // Object { value: '첫번째 호출', done: false } // Object { value: '두번째 호출', done: false } // Object { value: '세번째 호출', done: false } // Object { value: '네번째 호출', done: false } // Object { value: undefined, done: false } // Object { value: undefined, done: false } // Object { value: undefined, done: false } // Object { value: undefined, done: false } // Object { value: undefined, done: false } // Object { value: undefined, done: false } yield 제너레이터 함수를 중지 시키거나 재개하는데 사용한다. Syntax [rv] = yield [expression]; Parameters rv 제너레이터 실행을 재개 하기 위해서, optional value을 제너레이터의 next() 메서드로 전달하여 반환 expression 제너레이터 함수에서 제너레이터 프로토콜을 통해 반환값을 정의 한다. (Default : undefined) 참고자료 http://hacks.mozilla.or.kr/2015/08/es6-in-depth-generators/https://gist.github.com/qodot/ecf8d90ce291196817f8cf6117036997 "},"book/02.-front-end/03.-javascript/03.-performance/":{"url":"book/02.-front-end/03.-javascript/03.-performance/","title":"03. Performance","keywords":"","body":"03. Performance 비 차단 스크립트 HTML Parsing 작업의 중단 없이 동시에 내려받게 됨 aync HTML 파싱과 동시에 다운 받으며 스크립트 다운로드가 끝났을 경우 HTML 파싱을 중지 시키고 스크립트 파싱한다. defer HTML 파싱과 동시에 다운 받으며 스크립트 다운로드가 끝나도 HTML 파싱이 완료된 이후에 스크립트 파싱을 시작한다. "},"book/02.-front-end/03.-javascript/03.-performance/scope-closure.html":{"url":"book/02.-front-end/03.-javascript/03.-performance/scope-closure.html","title":"Scope & Closure","keywords":"","body":"스코프 (scope) 와 클로저 (closure) 렉시컬 스코프 (Lexical Scope) 스코프는 함수를 호출할 때가 아니라 선언할 때 생성 된다.이것은 렉시컬 스코프의 특징이며 동적 스코프와 비교된다. 아래 예시에서는 선언할 때 생성되는 것을 확인할 수 있다. var color = 'red'; function foo() { var color = 'blue'; function bar() { console.log(color); } return bar; } var baz = foo(); baz(); blue ES5는 함수레벨의 렉시컬 스코프를 가진다. ES6는 함수레벨과 블록레벨의 렉시컬 스코프를 가진다. 동적 스코프 (Dynamic Scope) 함수가 어디서 호출되었는지에 따라 상위 스코프가 결정 function foo() { console.log(x); } function bar() { var x = 15; foo(); } var x = 10; foo(); bar(); 기존 (렉시컬 스코프) 10 10 동적 스코프 가정 시 10 15 참고자료 https://bestalign.github.io/2015/07/12/Lexical-Scope-and-Dynamic-Scope/ 순환참조 이는 잘못된 클로저 사용시 서로가 서로를 참조하는 순환 참조 현상이 발생 될 수 있다. 순환참조가 발생되면 GC (Gabege Collection) 대상에서 벗어나기 때문에 메모리 누수의 원인으로 잔여하게 된다. 참고자료 https://hyunseob.github.io/2016/08/30/javascript-closure/https://meetup.toast.com/posts/86https://engineering.huiseoul.com/자바스크립트는-어떻게-작동하는가-메모리-관리-4가지-흔한-메모리-누수-대처법-5b0d217d788dhttp://www.nextree.co.kr/p7363/ "},"book/02.-front-end/03.-javascript/03.-performance/memory_leak.html":{"url":"book/02.-front-end/03.-javascript/03.-performance/memory_leak.html","title":"Memory Leak","keywords":"","body":"메모리 누수 웹 페이지 내에서 무거운 자바스크립트 코드 사용사에 페이지 성능에 영향을 미치는 메모리 문제를 찾아내는 방법을 알아본다.메모리 누수, 메모리 팽창, 잦은 가비지 수집 등이 대표적인 원인으로 꼽힌다. 메모리 팽창과 누수의 판별 단순히 사이트의 점점 더 많은 메모리를 사용하게 된다면 누수가 발생된다고 볼 수 있다.여기서 많은 메모리의 기준은 RAIL 모델을 사용하여 사용자에게 주안점을 두는것이다. RAIL 모델 사용자 중심의 성능 모델로 다음 네가지의 측면을 반영한다. Response 사용자의 입력은 100ms 내에 인지해야 함 Animation 애니메이션의 스크롤 시간을 10ms 이내에 프레임을 생성해야 함 Idle 메인 스레드의 유휴시간을 극대화 해야 함 Load 대화형 콘텐츠의 경우 1000ms 이내에 전달해야 함 메모리 누수 예방 및 분석 크롬 (Chrome) 의 작업 관리자로 메모리 사용량을 실시간 모니터링 타임라인 (Timeline) 기록으로 메모리 누수의 시각화 힙 스냅샷으로 분리된 DOM 트리 메모리 누수의 발견 Javascript 힙 (Heap) 메모리 누수 파악 (Allocation Timeline) 함수별 메모리 할당 관측 잦은 가비지 수집 관측 해결방법 크롬 작업관리자를 사용하여 확인 가능 시간의 흐름에 따른 메모리 사용량을 타임라인으로 기록하여 시각화한다. 분리된 DOM 트리 (일반적인 메모리 누수 원인) 을 힙 스냅샷으로 식별할 수 있다. JS 힙에 새 메모리가 할당될 때 할당 타임라인 기록을 확인하여 알아낼 수 있다. 참고자료 https://developers.google.com/web/tools/chrome-devtools/memory-problems/?hl=ko https://developers.google.com/web/fundamentals/performance/rail?hl=ko "},"book/02.-front-end/03.-javascript/03.-performance/netfunnel.html":{"url":"book/02.-front-end/03.-javascript/03.-performance/netfunnel.html","title":"NetFunnel","keywords":"","body":"NetFunnel (넷퍼넬) 지연 네트워킹의 한 방법으로 Aim To G 사 에서 개발한 지연 네트워킹 서비스 솔루션이다. 대부분 대량의 접속처리시에 대기열을 만들어 놓고 순차적으로 처리하는 방식으로쿠폰, 예매, 대용량 트래픽 처리시에 용이하다. JS 단에서 실제 자원 호출 전에 NetFunnel 모듈을 호출하여 자원을 먼저 호출하여 사용 가능 상태인지 확인 후 처리한다. // NetFunnel_Action( overriding params:Object, callback:Function ); NetFunnel_Action({ service_id:'SERVICE ID', action_id:'ACTION ID', skin_id:'SKIN ID' }, function(ev, ret){ /* success statement */ /* Ajax Logic */ }) Action Key 키 반납 NetFunnel_Complete({ service_id:'SERVICE ID', action_id:'ACTION ID', skin_id:'SKIN ID' }, function(ev, ret) { }); "},"book/02.-front-end/03.-javascript/03.-performance/event-loop.html":{"url":"book/02.-front-end/03.-javascript/03.-performance/event-loop.html","title":"Event Loop","keywords":"","body":"Event Loop 자바스크립트는 단일 스레드 (Single Thread) 기반이기 때문에 이벤트 루프를 사용하여 작업을 스케쥴링 한다. 이것은 시간에 흐름에 따라 코드의 수행을 처리하며 그때마다 JS Engine 을 실행하며 아래 그림과 같은 구조적 특성을 띈다. 이에 따른 이벤트 루프는 단 한가지의 임무만 가지고 있는데 Call Stack 와 Callback Queue 을 감시하는 것 이다. 만약 콜스택이 비어 있으면 이벤트 루프에서는 큐에서 첫번째 이벤트를 가져다가 Call Stack 에 밀어넣는것이며 결과적으로 해당 이벤트가 실행되는 것이다. 대표적인 예로 setTimeout 동작이 있다. setTimeout 이 자동으로 콜백을 이벤트 루프 큐 안에 넣어주지는 않는다. setTimeout 은 타이머를 설정하며 타이머가 만료되면 호스팅 환경이 콜백을 이벤트 루프에 위치시켜 미래의 Tick 이 이를 가져다 수행할 수 있도록 한다. setTimeout(() => { alert('Callback Func'); }, 1000); 즉 위에 코드는 setTimeout 은 1,000ms 후에 실행이 아닌 1,000ms 이후에 Callback Queue 에 추가되는 것이다. 콜스택, 콜백큐 등의 모든것이 비워져있다. console.log('Hi') 가 콜스택에 추가되었다. console.log('Hi') 가 실행된다. console.log('Hi') 가 콜 스택에서 제거되었다. setTimeout(function cb1() {...}) 가 콜스택에 추가되었다. setTimeout(function cb1() {...}) 이 실행되면서 브라우저가 웹 API 의 일환인 타이머를 생성한다.이 타이머는 카운트 다운을 처리한다. setTimeout(function cb1() {...}) 가 실행이 완료되고 콜스택에서 제거된다. console.log('Bye') 가 콜스택에 추가되었다. console.log('Bye') 이 실행되었다. console.log('Bye') 가 콜스택에서 제거되었다. 타이머가 완료되면 cb1 을 콜백큐에 밀어 넣는다. 이벤트 루프가 cb1 을 콜백큐에서 가져다 콜스택에 밀어 넣는다. cb1 이 실행되고 console.log('cb1') 이 콜스택에 추가된다. console.log('cb1') 이 실행된다. console.log('cb1') 이 콜 스택에서 제거된다. 'cb1` 이 콜스택에서 제거된다. 참고자료 https://engineering.huiseoul.com/자바스크립트는-어떻게-작동하는가-이벤트-루프와-비동기-프로그래밍의-부상-async-await을-이용한-코딩-팁-다섯-가지-df65ffb4e7e "},"book/02.-front-end/04.-framework/":{"url":"book/02.-front-end/04.-framework/","title":"04. Framework","keywords":"","body":"04. Framework 쿼리스트링 (리소스 파일 캐쉬 방지) 브라우저에서 캐의 동작은 기존에 동일한 URL 에 요청한 적이 있었는지 판단한다.따라서 수정 배포된 리소스파일 (js, css, image 등등 ...) 이 수정되면 URL 경로의 변경 혹은 쿼리스트링으로 파일 캐시를 방지한다. 코드적 장점 매번 캐시를 삭제해야 하는 불편함을 피할 수 있다. 관리적 장점 파일의 릴리즈 (release) 버전의 정보를 알기 쉽게 구분한다. "},"book/02.-front-end/04.-framework/node-js/":{"url":"book/02.-front-end/04.-framework/node-js/","title":"Node JS","keywords":"","body":"Node JS "},"book/02.-front-end/04.-framework/node-js/http-transection.html":{"url":"book/02.-front-end/04.-framework/node-js/http-transection.html","title":"HTTP Transection","keywords":"","body":"HTTP Transection 요청 처리 서버의 생성 모든 node 웹 서버 어플리케이션은 웹 서버 객체를 만들어야 합니다.이때 createServer 를 이용합니다. const http = require('http'); const server = http.createServer((request, response) => { // Work Process }); 서버로 오는 모든 HTTP 요청 마다 createServer 에 전달된 함수가 한번씩 호출된다.createServer 가 반환한 Server 객체는 EventEmitter 이고 server 객체를 생성하고 리스너를 추가하는 축약 문법이다. EventEmitter 이란 ?이벤트 모듈의 의해 정의 되며 새로운 이벤트가 추가되거나 삭제될 때 이벤트를 내보냅니다. const http = require('http'); const server = http.createServer(); server.on('request', (req, res) => { // Work Process }); HTTP 요청이 서버에 오면 node 가 트랜잭션을 다루려고 request 와 response 객체를 전달하며 요청 핸들러 함수를 호출 합니다. Method, URL, Header 의 처리 요청을 처리할 때, 우선은 Method 와 URL 을 확인한 후 이와 관련된 작업을 실행합니다.node 는 request 객체에 대부분의 프로퍼티를 넣어두므로 꺼내서 사용하면 된다. const {method, url} = request; request 객체는 IncomingMessage 의 인스턴스이다. IncomingMessage Class 의 특징 HTTP 에 의해 생성된다. 특정 객체의 첫번째 변수로 전달되는 인수 (SERVER http.ClientRequest request event response event) 응답상태 및 헤더, 데이터 등을 액세스 하는데 사용 한다. 헤더 또한 request 객체에서 얻어온다. const {headers} = request; const userAgent = header['user-agent']; Tips 클라이언트가 설정한 헤더 프로퍼티는 대소문자 구분없이 소문자로만 표현 된다.일부 헤더 정보를 반복해서 설정하면 overwrite 하거나 csv 형태로 구성될 수 있다. 이런 경우에는 rawHeaders 를 사용할 수 있다. Request Body 의 처리 post 혹은 put 요청시 핸들러에 전달된 request 객체는 ReadableStream 인터페이스를 구현하고 있다.이 스트림에 EventListener 를 등록하거나 다른 스트림의 파이프로 연결 할 수 있다. 각 data 이벤트에서 발생시킨 청크는 Buffer 이며 이는 문자열 데이터이다.이는 end 이벤트에서 이어 붙인 다음에 문자열로 만드는게 가장 좋다. let body = []; request.on('data', (chunk) => { body.push(chunk); }).on('end', () => { // `body` 에 전체 요청 바디가 문자열로 담겨 있다. body = Buffer.concat(body).toString(); }); 오류의 관한 처리 request 스트림에서 오류가 발생하면 error 이벤트가 발행하면서 오류를 전달한다.별도의 이벤트 리스너가 등록되어 있지 않다면 오류를 뱉으면서 Node.js 를 종료시킨다. request.on('error', (error) => { console.error(error.stack); }); HTTP 요청 코드 정리 const http = require('http'); http.createServer((request, response) => { const {headers, method, url} = request; let body = []; request.on('error', (error) => { console.error(error.stack); }).on('data', (chunk) => { body.push(chunk); }).on('end', () => { body = Buffer.concat(body).toString(); /** * 헤더, 메서드, 요청경로, 바디 등을 가지게 되었으며 * 이 요청에 응답하는 작업을 수행할 수 있습니다. */ }) }).listen(8080); 이 코드는 요청 받을 수 있지만 요청한 디바이스(클라이언트) 에 응답 하는 로직이 없기 때문에 타임아웃이 걸릴것 입니다. 응답 처리 응답 상태 코드 별도의 설정이 없으면 HTTP 응답 코드는 200 으로 고정 됩니다.상태 코드를 변경 하려면 statusCode 프로퍼티를 설정해야 합니다. // 리소스를 찾을수 없음 response.statusCode = 404; 응답 헤더 설정 setHeader 메서드로 헤더를 설정 한다. response.setHeader('Content-Type', 'application/json'); response.setHeader('X-Powered-By', 'bacon'); 헤더 설정 프로퍼티의 대/소문자는 구분이 없다. 명시적 응답 헤더 데이터 전송 writeHead 메소드를 이용하여 명시적으로 헤더 작성이 가능하다. response.writeHead(200, { 'Content-Type': 'application/json', 'X-Powered-By': 'bacon' }); 응답 바디 전송 response 객체는 WriteableStream 이므로 클라이언트로 보내는 응답 바디는 일반적인 스트림 메서드를 이용하여 작성 합니다. response.write(''); response.write(''); response.write('Hello, World!'); response.write(''); response.write(''); response.end(); 위 코드는 아래와 같이 작성해도 동일하다. response.end('Hello, World!'); 오류에 관한 처리 response 스트림도 error 이벤트를 발생시킬수 있고 때로는 이 오류도 처리해야 합니다.request 스트림에 대한 오류와 동일하게 적용이 가능합니다. 현재까지 적용코드 const http = require('http'); http.createServer((request, response) => { const { headers, method, url } = request; let body = []; request.on('error', (error) => { console.error(error); }).on('data', (chunk) => { body.push(chunk); }).on('end', () => { body = Buffer.concat(body).toString(); response.on('error', (error) => { console.error(error); }); response.statusCode = 200; response.setHeader('Content-Type', 'application/json'); // 위 두줄의 코드를 한줄로 가능 // response.writeHead(200, {'Content-Type': 'application/json'}); const responseBody = { headers, method, url, body }; response.write(JSON.stringify(responseBody)); response.end(); // 위 두줄의 코드를 한줄로 가능 // response.end(JSON.stringify(responseBody)); }); }).listen(8080); 에코 서버 만들기 에코서버란 요청 받은 데이터를 그대로 응답으로 돌려보내는 서버이다.앞에서 했던것 처럼 요청 스트림에서의 데이터를 가져와 응답 스트림에 쓴다. const http = require('http'); http.createServer((request, response) => { let body = []; request.on('data', (chunk) => { body.push(chunk); }).on('end', () => { body = Buffer.concat(body).toString(); response.end(body); }); }).listen(8080); 위 코드를 다음 조건에 따라 에코 응답을 보내는것으로 수정한다. 요청 메서드가 POST 인 경우 URL 이 /echo 인 경우 const http = require('http'); http.createServer((request, response) => { if (request.method === 'POST' && request.url === '/echo') { let body = []; request.on('data', (chunk) => { body.push(chunk); }).on('end', () => { body = Buffer.concat(body).toString(); response.end(body); }); } else { response.statusCode = 404; response.end(); } }).listen(8080); 위의 방법으로 라우팅을 하고 있지만 express 프레임워크나 router 라이브러리릉 통해서 처리도 가능하다. request 객체는 ReadableStream 이고 response 객체는 WriteableStream 이므로 pipe 를 사용할 수 있다. const http = require('http'); http.createServer((request, response) => { if (request.method === 'POST' && request.url === '/echo') { request.pipe('response'); } else { response.statusCode = 404; response.end() } }).listen(8080); 오류에 관한 처리 const http = require('http'); http.createServer(request, response) => { request.on('error', (error) => { console.error(error); response.statusCode = 400; response.end(); }); response.on('error', (error) =>{ console.error(error); }); if (request.method === 'POST' && request.url === '/echo') { request.pipe(response); } else { response.statusCode = 404; response.end(); } }).listen(8080); HTTP 요청을 다음 동작이 가능하다. 요청 핸들러로 HTTP 서버의 인스턴스를 생성 가능하고 특정 포트를 열 수 있다. request 객체에서 Header, Method, URL, Body` 데이터를 가져올 수 있다. URL 이나 request 객체의 기반 데이터로 라우팅이 가능하다. request 객체에서 response 객체로 데이터를 파이프로 연결 가능하다. request 와 response 스트림 모두에서 스트림 오류 처리가 가능하다. 참고자료 https://nodejs.org/ko/docs/guides/anatomy-of-an-http-transaction/ "},"book/02.-front-end/04.-framework/node-js/express.html":{"url":"book/02.-front-end/04.-framework/node-js/express.html","title":"Express","keywords":"","body":"Express Route 라우팅은 요청 URI 및 특정한 HTTP 요청 메소드 (GET, POST, PUT, DELETE) 인 특정 엔드포인트 에 대한 클라이언트 요청에 대해 애플리케이션이 응답하는 방법을 결정 하는것 Syntax app.METHOD(PATH, HANDLER) Parameter app express 의 인스턴스 METHOD HTTP 요청 메소드 PATH 서버 경로 HANDLER 라우트가 일치할 때 실행되는 함수 Example 각 요청에 따른 라우트를 정의하고 이에 응답한다. var express = require('express'); var app = express(); app.get('/', function(req, res) { res.send('hello world'); }); Method 대표적인 Express 라우팅 메소드는 다음과 같다. app.get('/', function (req, res) { res.send('Hello World!'); }); app.post('/', function (req, res) { res.send('Got a POST request'); }); app.put('/user', function (req, res) { res.send('Got a PUT request at /user'); }); app.delete('/user', function (req, res) { res.send('Got a DELETE request at /user'); }); Route Chain app.route() 을 이용하면 라우트 경로에 대한 체이닝 핸들러를 작성 할 수 있다. app.route('/book') .get(function(req, res) { res.send('Get a random book'); }) .post(function(req, res) { res.send('Add a book'); }) .put(function(req, res) { res.send('Update the book'); }); all() 메소드를 통해 모든 응답의 대응도 가능. app.route('/book') .all(function(req, res) { res.send('Get a random book'); }); Route Moduler 모듈식 마운팅이 가능한 핸들러의 작성 var express = require('express'); var router = express.Router(); // middleware that is specific to this router router.use(function timeLog(req, res, next) { console.log('Time: ', Date.now()); next(); }); // define the home page route router.get('/', function(req, res) { res.send('Birds home page'); }); // define the about route router.get('/about', function(req, res) { res.send('About birds'); }); module.exports = router; var birds = require('./birds'); ... app.use('/birds', birds); /birds 및 /birds/about 에 대한 요청을 처리 가능하며 해당 라우트에 대한 특정 미들웨어 함수인 timeLog 를 호출 Express 는 HTTP 메소드에 해당하는 다음과 같은 라우팅 메소드를 지원한다. get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search및 connect. Path URI 경로는 문자열 혹은 정규식의 패턴에도 적용된다. Character Pattern // acd, abcd app.get('/ab?cd', function(req, res) { res.send('ab?cd'); }); // abcd, abbcd, abbbcd app.get('/ab+cd', function(req, res) { res.send('ab+cd'); }); // abcd, abxcd, abRABDOMcd, ab123cd app.get('/ab*cd', function(req, res) { res.send('ab*cd'); }); // /abe, /abcde app.get('/ab(cd)?e', function(req, res) { res.send('ab(cd)?e'); }); Regular Expression // a 가 포함된 모든 항목과 일치 app.get(/a/, function(req, res) { res.send('/a/'); }); // butterfly, dragonfly 과는 일치 // butterflyman, dragonfly man 과는 불일치 app.get(/.*fly$/, function(req, res) { res.send('/.*fly$/'); }); Response 응답 오브젝트에 대한 메소드는 응답을 클라이언트에 전송하고 요청 및 응답의 주기를 종료할 수 있다.라우트 핸들러로부터 다음 메소드중 하나라도 호출되지 않는 경우 클라이언트 요청은 정지된 채로 방치 된다. 메소드 설명 res.download() 파일이 다운로드되도록 프롬프트합니다. res.end() 응답 프로세스를 종료합니다. res.json() JSON 응답을 전송합니다. res.jsonp() JSONP 지원을 통해 JSON 응답을 전송합니다. res.redirect() 요청의 경로를 재지정합니다. res.render() 보기 템플리트를 렌더링합니다. res.send() 다양한 유형의 응답을 전송합니다. res.sendFile 파일을 옥텟 스트림의 형태로 전송합니다. res.sendStatus() 응답 상태 코드를 설정한 후 해당 코드를 문자열로 표현한 내용을 응답 본문으로서 전송합니다. const router = express.Router(); // 클라이언트가 루트 경로로 진입하면 /index 경로로 리다이렉트 시킨다. router.all('/', (req, res) => { res.redirect('/index'); }); // 모든 경로를 index 로 랜더링 한다. router.all('*', (req, res) => { res.render('index'); }); "},"book/02.-front-end/04.-framework/angular-js.html":{"url":"book/02.-front-end/04.-framework/angular-js.html","title":"Angular JS","keywords":"","body":"Angular JS Browser Support 2 Way Binding Angular 1에서 많은 인기를 얻었던 특징중에 ng-model 지시자 (directive) 를 이용한 양방향 데이터 바인딩 (two-way binding) 이다.UI 에 연결된 데이터가 변경되면 앱의 상태가 자동으로 업데이트 되는 기능으로 예를 들면 박스에 사용자가 텍스트를 입력하여 값을 변경하면 자동으로 UI 에 onChange 같은 콜백 함수를 이용하지 않아도 자동으로 변수가 입력된 값을 업데이트 한다. Hello, {{name}} 장점 DOM 조작이 줄어든다. 단점 불필요한 성능 저하를 가져온다. 계속해서 데이터 변화를 감지하고 바인딩 해야 하기 때문 "},"book/02.-front-end/04.-framework/react/":{"url":"book/02.-front-end/04.-framework/react/","title":"React JS","keywords":"","body":"React JS ESLint .eslintrc.json 파일에 다음과 같이 추가해준다.es6 문법과 jsx 를 혼용하기 때문에 아래와 같은 lint 설정을 추가해준다. { ... \"parserOptions\": { \"ecmaVersion\": 6, \"sourceType\": \"module\", \"ecmaFeatures\": { \"jsx\": true } } ... } React Development Tools 손쉬운 디버그 환경을 위하여 크롬 확장프로그램 (Chrome Extension) 에서 해당 플러그인을 설치한다. 참고자료 React https://d2.naver.com/helloworld/1848131 https://reactjs.org/docs/getting-started.html https://velopert.com/3613 Redux https://deminoth.github.io/redux/ 왜 가상 돔 (Virtual DOM) 이 빠른이유 DOM 구조상의 Node 변경점이 생기면 레이아웃을 만들고 페인팅을 하는 과정에서 리소스가 발생된다.만약 30개의 노드가 바뀐다고 가정하면 30번의 (잠재적인) 레이아웃 재계산과 30번의 리랜더링을 초래하는것이다.이는 React 를 사용했을때 DOM 조작이 최종적인 결과물만 반영되기 때문에 모든 변화를 하나로만 묶어서 변화 시키는 것이다. 즉 브라우저가 연산하는 횟수를 줄이는데 집중 한다. 물론 최종 결과 값만 변경되기 때문에 궂이 Virtual DOM 을 사용하지 않아도 변화를 묶어서 DOM 에 반영 시켜 주면 되지만Virtual DOM 은 DOM fragment 를 관리하는 과정을 수동으로 하나하나 작업할 필요없이 자동화 하고 추상화하는것 에 있다.이러한 부분들을 자동화 해주는 편의를 제공하기 때문에 충분히 매력적이고 강력한 뷰 라이브러리인 것이다. 각 컴포넌트가 DOM 조작을 요청할 때 다른 컴포넌트들과 상호작용하지 않아도 되며, 특정 DOM 을 조작할 것이라던지, 혹은 이미 조작했다던지에 대한 공유를 할 필요가 없다. 즉 각각의 변화들을 동기화 작업을 거치지 않으면서 하나의 작업으로 묶을수 있는것이다. 참고자료 https://velopert.com/3236 Class Constructor 에서 super() 컴포넌트 안에서 생성자 (constructor) 를 실행하면 반드시 super() 를 실행해야 한다.생성자 (constructor) 를 사용하지 않으면 자동으로 실행해준다. 이는 this 객체를 초기화 해주지 않기 때문이다. class Myclass extends React.Component { constructor() { console.log(this); // Error : 'this' is not allowed before super(); } } 위와 같이 super() 실해 이전에 this 를 참조하면 허용되지 않는다. super() 를 호출할때 props 인자를 넘겨주면 constructor 안에서 this.props 를 접근 가능하게 구성해준다. class Myclass extends React.Component { constructor(props) { super(props); } } 위와 같이 사용해야 정상적으로 this.props 사용이 가능하다. 참고자료 https://medium.com/@umioh1109/react-es6-class-constructor%EC%97%90%EC%84%9C%EC%9D%98-super-9d53ba0611d9 "},"book/02.-front-end/04.-framework/react/lifecycle.html":{"url":"book/02.-front-end/04.-framework/react/lifecycle.html","title":"Lifecycle","keywords":"","body":"리엑트 라이프 사이클 (React Life Cycle) 리엑트의 라이프 사이클에 따른 메소드를 정의한다.아래 두 그림을 활용하여 확인해 보는것이 좋다. constructor 생성자 메소드 컴포넌트가 처음 만들어질때 실행된다. 기본 state 를 정의할 수 있다. constructor(props) { super(props); } componentWillMount 컴포넌트가 DOM 위에 만들어지기 전에 실행된다. componentWillMount() { /* statement */ } render 컴포넌트 렌더링을 담당한다. render() { return ( Hello World ); } componentDidMount 컴포넌트가 만들어지고 첫 렌더링을 다 마친후 실행되는 메소드 외부 JavaScript Framework 를 연동하거나 setTimeout, setInterval 및 AJAX 처리 등을 작성한다. componentDidMount() { /* statement */ } componentWillReceiveProps 컴포넌트가 prop 를 새로 받았을 때 실행됩니다. prop 에 따라 state 를 업데이트 해야 할 때 사용하면 유용하다. 이 안에서 this.setState() 를 해도 추가적으로 렌더링하지 않는다. componentWillReceiveProps(nextProps) { console.log(JSON.stringify(nextProps)); } shouldComponentUpdate prop 혹은 state 가 변경되었을 때, 리 랜더링 여부를 결정짓는 메소드 리 랜더링 여부를 Boolean 타입으로 반환 shouldComponentUpdate(nextProps, nextState) { console.log(JSON.stringify(nextProps)); console.log(JSON.stringify(nextState)); return nextProps.id === this.props.id; } componentWillUpdate 컴포넌트가 업데이터 되기 전에 실행됩니다. 이 메소드 안에서 this.setState() 를 사용하면 무한루프에 빠진다. componentWillUpdate(nextProps, nextState) { console.log(JSON.stringify(nextProps)); console.log(JSON.stringify(nextState)); } componentDidUpdate 컴포넌트가 리 랜더링을 마친 후 실행 componentDidUpdate(prevProps, prevState) { console.log(JSON.stringify(prevProps)); console.log(JSON.stringify(prevState)); } componentWillUnmount 컴포넌트가 DOM 에서 사라진 후 실행되는 메소드 입니다. componentWillUnmount() { /* statement */ } "},"book/02.-front-end/04.-framework/react/redux.html":{"url":"book/02.-front-end/04.-framework/react/redux.html","title":"Redux","summary":"자바스크립트 앱의 상태 데이터를 관리해주는 하나의 도구 (Angular, React, jQuery 에서도 사용 가능)","keywords":"","body":"Redux "},"book/02.-front-end/04.-framework/vue/":{"url":"book/02.-front-end/04.-framework/vue/","title":"Vue","keywords":"","body":"Vue Methods 내부적으로 사용가능한 함수들을 모아놓는다. export default { data() { value = null }, methods: { /* 내부 함수목적으로 주로 사용 */ } } Computed 내부 캐시를 사용하기 때문에 계산된 속성만 사용하는것을 추천한다. Getter 속성 목적으로만 사용하며 필요에 의해서는 Setter 사용이 가능하다. export default { data() { return { value: '' }; }, computed: { getValue: { get: () => this.value, set: value => this.value = value } } } Watch 변수가 변경되는것을 감지하여 이전값과 새로운 값을 제공한다. 일반적인 변수를 포함하여 computed 함수 선언과 동시에 사용가능하다. export default { data() { return { value: '' }; }, computed: { getValue: { get: () => this.value, set: value => this.value = value } }, /* 변수가 변경되는 것을 감지 */ watch: { getValue(newValue, oldValue) { console.log('새로운 값 : ' + newValue); console.log('오래된 값 : ' + oldValue); } } } "},"book/02.-front-end/04.-framework/vue/lifecycle.html":{"url":"book/02.-front-end/04.-framework/vue/lifecycle.html","title":"Lifecycle","keywords":"","body":"뷰 라이프 사이클 (Vue Life Cycle) 뷰의 라이프 사이클은 크게 다음 네가지로 나뉜다. Creation Mounting Updating Destruction 이는 각 단계마다 아래와 같은 특징이 있다. Creation :: 컴포넌트 초기화 컴포넌트 초기화 단계 beforeCreate 모든 훅 중에서 가장 먼저 실행되는 훅 data 와 event 가 세팅되지 않는 시점으로 접근하면 에러를 뿜는다. export default { data() { return {}; }, beforeCreate() { /* statement */ } } created data 와 event 가 활성화 되어 접근 가능한 상태 Template 과 VirtualDOM 은 랜더링되지 않는 상태이다. export default { data() { return {}; }, created() { /* statement */ } } Mounting :: DOM 삽입 단계 초기 랜더링 직전에 컴포넌트에 접근 가능한 상태 (SSR 지원 불가) beforeMount export default { beforeMount() { /* statement */ } } mounted 컴포넌트, 템플릿, 랜더링된 DOM 에 접근할 수 있다. 모든 하위 컴포넌트가 마운트된 상태를 보장하지 않는다. vm.$nextTick 를 사용하면 전체가 랜더링된 상태를 보장할 수 있다. (SSR 지원 불가) export default { mounted() { this.$nextTick(() => { /* 모든 화면이 랜더링된 후 실행함 */ }); } } 부모 자식 관계의 Mount 관계에 있을 경우에는 다음 순서를 보장한다. Updating :: Diff 및 재 랜더링 단계 beforeUpdate 컴포넌트의 데이터가 변하여 업데이트 사이클이 시작될때 실행 DOM이 재 랜더링되고 Fetch 되기 직전에 실행 재 랜더링되기 이전의 새 상태의 데이터를 얻을수 있으며 더 많은 변경이 가능하다. 이 변경으로인한 재 랜더링은 트리거 되지 않는다. export default { beforeUpdate() { /* statement */ } } updated 컴포넌트 데이터가 변하여 재 랜더링이 일어난 후 실행된다. DOM이 업데이트 완료된 상태이므로 DOM의 종속적인 연산을 할 수 있다. 여기서 상태를 변경하면 무한루프에 빠질수 있다. vm.$nextTick 를 사용하면 전체가 재 랜더링된 상태를 보장할 수 있다. export default { updated() { this.$nextTick(() => { /* 모든 화면이 재 랜더링된 후 실행함 */ }); } } Destruction :: 해체 단계 beforeDestroy 뷰 인스턴스 제거되기 직전에 호출 컴포넌트의 원래 모습과 기능들을 그대로 가지고 있다. 이벤트 리스너를 제거 하거나 reactive subscription 을 제거 하고자 할 때 사용한다. (SSR 지원 불가) export default { beforeDestroy() { /* statement */ } } destroyed 뷰 인스턴스 제거된 후 호출된다. (SSR 지원 불가) 모든 이벤트 리스너가 제거된다. 모든 하위 (자식) 리스너가 제거된다. export default { destroyed() { /* statement */ } } 참고자료 https://medium.com/witinweb/vue-js-라이프사이클-이해하기-7780cdd97dd4https://alligator.io/vuejs/component-lifecycle/ "},"book/02.-front-end/05.-library/":{"url":"book/02.-front-end/05.-library/","title":"05. Library","keywords":"","body":"Library jQuery 버전 확인 방법 console.debug(\"jQuery \"+ (jQuery ? $().jquery : \"NOT\") +\" loaded\"); "},"book/02.-front-end/05.-library/D3/":{"url":"book/02.-front-end/05.-library/D3/","title":"D3","keywords":"","body":""},"book/02.-front-end/05.-library/D3/line.html":{"url":"book/02.-front-end/05.-library/D3/line.html","title":"Line","keywords":"","body":""},"book/02.-front-end/05.-library/D3/force-layout.html":{"url":"book/02.-front-end/05.-library/D3/force-layout.html","title":"Force Layout","keywords":"","body":""},"book/03.-back-end/":{"url":"book/03.-back-end/","title":"03. Back End","keywords":"","body":"03. Back End SQL 인젝션 "},"book/03.-back-end/01.-java/":{"url":"book/03.-back-end/01.-java/","title":"01. Java","keywords":"","body":"01. Java Java 언어의 전반적인 이야기를 다룹니다. Log4j Log Level TRACE 해당되는 내용에 대한 경로추적을 위해 사용 DEBUG 디버깅을 위한 목적 INFO 시스템 동작에 대한 정보를 제공 버그나 시스템 문제는 아니고, 단지 운영자에게 정보를 제공 WARN 현재 운영에는 문제가 없지만, 문제가 될 수 있는 사항 예외가 발생하지는 않았지만 해당 정보에 대해서 알려주어야 할 경우 ERROR 시스템 운영에 문제가 있을 만한 사항 보통 예외를 잡아서 정상처리한 경우 기록 FATAL 시스템 운여이 불가능한 경우 보통 예외가 발생하고 정상 처리 못한 경우 Layout %d : 로그의 기록시간을 출력 %p : 로깅의 레벨을 출력 %F : 로깅이 발생한 프로그램의 파일명을 출력 %M : 로깅이 발생한 메소드의 이름을 출력 %I : 로깅이 발생한 호출지의 정보를 출력 %L : 로깅이 발생한 호출지의 라인수를 출력 %t : 로깅이 발생한 Thread명을 출력 %c : 로깅이 발생한 카테고리를 출력 %C : 로깅이 발생한 클래스명을 출력 %m : 로그 메시지를 출력 %n : 개행 문자를 출력 %% : %를 출력 %r : 어플리케이션이 시작 이후부터 로깅이 발생한 시점까지의 시간(ms)을 출력 %x : 로깅이 발생한 Thread와 관련된 NDC(Nested diagnostic context)를 출력 %X : 로깅이 발생한 Thread와 관련된 MDC(Mapped diagnostic context)를 출력 Sample [%d{yyyy-MM-dd HH:mm}] %5p (%F:%L) %M: %m%n [%d{HH:mm:ss}] %-5p %C{1}.%M(%F:%L) - %m%n 참고자료 http://tcpschool.com/java/intro "},"book/03.-back-end/01.-java/01.-general/":{"url":"book/03.-back-end/01.-java/01.-general/","title":"01. General","keywords":"","body":"General JDK & JRE 차이점 JDK (Java Development Kit) Java 의 응용프로그램을 개발할 수 있는 소프트웨어 개발 키트이다. JRE (Java Runtime Environment) Java 프로그램 코드가 실행되는 JVM 을 지칭함 static 키워드의 의미 Java Class 의 멤버 변수 또는 메소드가 속한 클래스의 인스턴스화를 요구하지 않고 액세스 할 수 있는 접근제어자 입니다.static 접근 제어자로 지정된 변수 혹은 메서드는 Java Runtime 시에 Compile 시에 정적으로 바인딩 되기 때문에 재정의 (수정) 이 불가 합니다. Java 의 다중상속 Java 는 구조적으로 다중 상속이 불가능 하다. 각 클래스는 하나의 클래스에서만 상속이 가능하지만 두 개이상의 인터페이스의 구현은 가능하다. 인터페이스 (interface) 와 추상 클래스(abstract) 의 공통점 & 차이점 인터페이스 (interface) 와 추상 클래스 (abstract) 는 근본적으로 다른 목적에 의해 구현된다. interface abstract 목적 함수의 구현을 강제화 상속을 통하여 기능을 이용하고 확장함 구현 방식 반드시 모든 메소드를 구현 모든 메소드를 구현하지 않아도 됨 다중 상속 가능 불가 접근 제어자 public private, protected, public 변수 기본적으로 final 로써 최종 변수임 비 최종 변수를 포함할 수 있음 Java 8 이전까지는 Interface 안에 static 메서드를 선언할 수 없었다. 이는 static 클래스인 경우에는 클래스 자체가 JVM 기동하면서 바로 로딩 된다.Interface 나 Abstract Class 인 경우 클래스가 생성되어진 이후에 해당 객체를 Reference 하게 된다.상대적으로 로딩시간이 앞서 있는 static 클래스에 대해서는 interface 나 Abstract 클래스의 구현이 불가하다 관련출처 https://groups.google.com/forum/#!topic/ksug/XJAznUUFQl4 Call By Value & Reference 의 차이 Java 에서 Call By Value 를 통한 값 전달 방식은 객체의 복사본이 전달된다는 것을 의미한다.즉 원본 데이터에 영향을 주지 않는다. 객체가 참조로 전달되면 이는 실제 객체가 전달되지 않는 참조객체의 전달 을 의미한다. Boxing & Unboxing (박싱 & 언방식) Java 의 데이터는 클래스나 객체와 같은 참조자료형 과 기본적인 원시타입 을 가질 수 있다.이는 다시 말해 각각의 기초 자료형을 포장되어 있는 Wrapper Class 로 변환이 가능하다. graph LR A[\"기본 (원시) 타입\"] -- Boxing --> B[\"참조 자료형\"] B -- Unboxing --> A Boxing : 값 (기초 타입) 을 참조 형식으로 변환 Unboxing : 참조 형식을 값 형식으로 변환 기본형 타입 참조 자료형 (Wrapper Class) byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean void Void // Boxing Object a = 20; // UnBoxing int b = (int) a; Boxing 과정 graph TD; A[\"값 타입을 힙에 생성하기 위해 메모리를 힙 영역에 생성\"]-->B[\"값을 힙 영역에 할당된 메모리로 복사\"]; B-->C[\"참조할 변수에 할당된 메모리 주소를 할당\"]; Unboxing 과정 graph TD; A[\"Boxing 값인지 확인\"]-->B[\"Boxing 된 값이면 값유형의 변수에 복사\"]; B-->C[\"박싱한 메모리와 언박싱한 메모리 2개 존재\"]; 문제점 모든 객체가 값 형식으로 언박싱 될 수 없고, 이전에 박싱된 데이터에 한하여 언박싱이 가능하다. 또한 박싱된 데이터의 타입을 따라야 한다. 박싱 작업은 완전히 새로운 객체가 만들어져야 하며 이러한 작업은 할당 작업보다 최대 20배의 시간 이 걸린다고 한다 언박싱의 캐스팅 시간은 할당작업보다 4배이상 의 시간이 걸린다고 한다. Example - JAVA public class Sum { // 캐스팅 시간 4배, 박싱 작업 20배 느려짐 예제 public static void main (String[] args) { // long sum = 0L; Long sum = 0L; for (long i = 0; i 참고자료 http://grayt.tistory.com/87 Access Modifier (접근 제어자) Java 에는 다음과 같은 접근 제어자가 있다.다음 순으로 접근을 허용한다. graph LR A[\"Private\"] --> B[\"Default\"] B --> C[\"Protected\"] C --> D[\"Public\"] Private 해당 클래스 내에서만 접근 가능하다. Default 접근 제어자를 따로 설정하지 않은 변수 혹은 메소드는 default 접근 제어자가 되어 해당 패키지 내에서만 접근 가능하다.해당 패키지 내에서만 접근 가능하다. Protected 동일패키지 내의 클래스에서 접근 가능하다. 해당 클래스를 상속 받은 외부 패키지의 클래스에서 접근 가능 하다. Public 어떤 클래스에서라도 접근 가능하다. 참고자료 https://wikidocs.net/232 객체 재사용 대표적으로 Singleton 디자인 패턴과 같이 미리 사전에 생성된 Instance 를 재사용하는 방식으로 일반적으로 ThreadPool 이나 Connection Pool 등의 방식으로 주로 사용한다. 초기화 블럭 (Initialization Block) 클래스 초기화 블럭과 인스턴스 초기화 블럭이 있다. public class TEST { static int a; int b; static { System.out.println(\"Static initialization\"); // 1 } { System.out.println(\"Instance initialization\"); // 2 // 4 } public TEST() { System.out.println(\"Constructor\"); // 3 // 5 } public static void main(String[] args) { new TEST(); new TEST(); } } Static initialization Instance initialization Constructor Instance initialization Constructor "},"book/03.-back-end/01.-java/01.-general/jvm.html":{"url":"book/03.-back-end/01.-java/01.-general/jvm.html","title":"JVM","keywords":"","body":"JVM (Java Vertual Machine) 프로그램을 실행하기 위해 물리적 머신 (컴퓨터) 과 유사하게 만든 머신을 소프트웨어로 구현한 것으로실제로 Java Byte Code 를 실행할 수 있는 프로세스 가상 머신 이다. OS 별로 종류가 다른데 MS Window & Linux 등의 환경에서는 HotSpot VM, IBM AIX 의 경우에는 IBM J9 이 사용된다. 특징 자바의 가상머신으로 OS 에 종속적이지 않아 독립적으로 운영된다. GC (Garbage Collection) 은 사용자에 의해 명시되지 않으며 자동으로 메모리 관리가 된다. 프로그램이 실행되면 JVM 은 OS 로부터 프로그램이 필요로하는 메모리를 할당 받고, JVM 은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리 한다. JVM 외부 Java 로 작성한 코드는 Class Loader 가 컴파일된 Java Byte Code 를 Runtime Data Areas 에 로드하고 Excution Engine 이 Java Byte Code 를 실행 Compile Running 소스코드를 작성 Compiler 는 JAVA 소스코드를 이용하여 클래스 파일을 생성 컴파일된 파일은 JVM (Java Virtual Machine) 이 인식 가능한 바이너리 파일로 변환 JVM 은 클래스 파일의 바이너리 코드를 해석하여 프로그램을 실행 수행 결과가 컴퓨터에 반영 Class Loader (클래스 로더) 자바는 Runtime 시에 Class 를 로드하고 링크하는 Dynamic Loading 특징이 있다. 이 Dynamic Loading 특징을 담당하는 부분이 Class Loader 이다. Class Loader 는 로드된 클래스를 보관하는 Namespace 를 갖는데,이미 로드된 클래스 인지 확인하기 위하여 Namespace 에 보관된 FQCN 을 기준으로 클래스를 찾는다. FQCN (Fully Qualified Class Name) ? 클래스가 속한 패키지명을 모두 포함한 이름을 말한다.보통 java.lang.String s = new java.lang.String(); 과 같이 Alias Name (축약) 형이 아닌 패키지를 모두 포함한 경로Class Loader 에서는 비록 FQCN 이 같더라도 Namespace 가 다르면 다른 클래스로 간주 Class Loader 의 대표적인 역활은 사용자가 작성한 Java Byte Code 를 JVM 메모리상에 올려주는 역활을 한다. 클래스 로더 특징 클래스 로더는 다음과 같은 특징이 있다. Hierarchical (계층 구조) 클래스 로더끼리 부모 자식 관계를 이루어 계층 구조로 구성된다. 최 상의 클래스 로더는 부트스트랩 (Bootstrap Class Loader) 클래스 로더이다. Delegate Load Request (위임 모델) 계층 구조를 기반으로 클래스 로더끼리 로드를 위임하는 구조로 동작 한다. 클래스를 로드할 때 먼저 상위 클래스로더를 확인하여 존재하면 해당 클래스를 사용하고 없으면 요청 받은 클래스 로더가 클래스를 로드한다. Have Visibility Constraint (가시성) 하위 (자식) 클래스 로더는 상위 (부모) 클래스 로더를 찾을수 있지만 그 반대의 경우 (부모 -> 자식) 은 있을 수 없다. Cannot unload Classes (언로드 불가) 클래스 로더는 Unload 기능을 하지 않는다. (Unload 는 GC 자동으로 함) 클래스 로더 요청 처리 Class Loader 가 Class Load 를 요청 받으면, 아래 순서대로 검색을 한다. graph LR; A[\"Class Loader Cache\"]-->B[\"Parent Class Loader\"]; B-->C[\"Self\"]; Bootstrap Class Loader 까지 확인해도 없으면 요청 받은 클래스 로더가 파일 시스템에서 해당 클래스를 찾음 참고자료 https://m.blog.naver.com/PostView.nhn?blogId=choigohot&logNo=40192701035&proxyReferer=https%3A%2F%2Fwww.google.com%2F Runtime Data Areas (런타임 데이터 영역) Class Loader 에서 로드해준 데이터를 보관하여 애플리케이션을 수행한다.이 수행 작업시에 사용되는 저장 및 참조로 하는 메모리 영역이다. Method Area 모든 Thread 가 공유하는 메모리 영역 class interface method field static valuable byte code 등을 보관 임포트된 클래스가 로드되는 영역 Heap Area 프로그램 상에서 데이터를 저장하기 위해 동적으로 할당하여 사용 하는 메모리 영역 실제로 Runtime 시 동적으로 할당하여 사용하는 영역 자바 프로그램은 new 연산자를 사용하여 객체를 동적으로 생성 Method Area 에 로드된 클래스만 생성 가능 class 를 이용하여 instance 를 생성하면 해당 영역에 저장하여 사용 여러 Thread 가 이 영역을 공유 한다. 이 영역은 GC (Garbage Collector) 를 통해서만 메모리 해제가 가능하다. (GC 의 실제적인 대상) Method 영역이 클래스 정보를 참고하여 인스턴스를 생성하는 곳 이다. JVM Stack Area Method 가 호출될 때마다 Stack Frame 이라는 데이터 영역이 생성하여 구성 Method 에 사용되는 Thread 의 수행 정보를 Stack Frame 을 통해서 저장 Thread 가 시작될때 생성하며, Thread 별로 생성되기 때문에 다른 Thread 는 접근 할 수 없다. Method 의 정보, Local Valuable, Argument 등의 연산 중 발생되는 임시 데이터 등이 저장 된다. Method 수행 되는 동안만 사용되며 메소드의 수행이 끝나면 필요 없게 된다. Method 가 호출될 때는 필요로하는 변수를 Stack 에 저장 하고, Method 실행이 끝나면 Stack 을 반환 한다. 실행중인 Thread 에 따라 각각 구성 하게 된다. PC Register 실행중인 각 Thread 는 별도의 PC Register 를 가지며, 명령이 실행되면 현재 실행중인 명령의 주소를 유지한다. Native Method Stack JAVA 외의 언어로 작성된 네이티브 코드들을 위한 Stack JNI (Java Native Interface) 를 통하여 호출되는 C/C++ 등의 코드를 수행하기 위한 Stack 애플리케이션에서 Native Method 를 호출하게 되면 내부에 Stack Frame 을 생성하여 Push 한다. JNI 를 이용하여 JVM 내부에 영향을 주지 않기 위함 Native Method Stack 을 실행할때는 JVM 을 거치지 않고 바로 수행한다. Thread 마다 하나씩 생성 PC Register JVM Stack Native Method Stack Thread 끼리 공유 Heap Area Method Area Runtime Constant Pool 참고자료 http://limkydev.tistory.com/51http://postitforhooney.tistory.com/entry/JavaJVM-JVM-이해를-통한-Java-작동원리-이해하기https://m.blog.naver.com/PostView.nhn?blogId=choigohot&logNo=40192701035&proxyReferer=https%3A%2F%2Fwww.google.com%2Fhttps://medium.com/@lazysoul/jvm-이란-c142b01571f2 Excution Engine (실행 엔진) Class Loader 를 통하여 JVM 메모리상에 배치되어 있는 바이트 코드를 Excution Engine 에 의해 실행된다. Excution Engine 는 Java Byte Code 를 명령어 단위로 읽어서 실행한다. (CPU 가 기계어 & 명령어 를 하나씩 읽어서 실행하는 것 과 비슷하다 ) Java Byte Code 의 각 명령어는 1 Byte 의 OpCode 와 추가 피 연산자로 이루어져 있으며, 실행 엔진은 하나의 OpCode 를 가져와서 피 연산자와 함께 작업을 수행한 다음, OpCode 를 수행하는 식으로 동작 Java Byte Code 는 기계어에 가깝기 보다는 비교적 인간이 보기 편한 행태로 기술한다. Excution Engine 는 이와 같이 바이트 코드가 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경 최초의 JVM 은 Interpreter 방식으로 수행되었다. Interpreter (인터프리터) Byte Code 명령어를 하나씩 읽어서 해석한다.이로 인해 실행이 느리다는 단점을 가지고 있다. 이를 개선하기 위해 JIT Compiler 를 도입하여 개선을 한다. JIT (Just In Time) Compiler Interpreter 방식으로 실행하다 적절한(?) 시점에 Byte Code 전체를 Compile 하여 Native Code 로 변경하며 이후에는 해당 메서드를 더 이상 Interpreting 하지 않고 Native Code 로 직접 실행하는 방식 Native Code 를 실행하는 것이 명령어 단위로 Interpreting 하는것보다 빠르며, Native Code 는 내부 캐시에 보관하기 때문에 한번 Compile 한 코드는 계속 빠르게 수행 graph LR; A[Java Source Code]-->|Java Compiler|B[Byte Code] B-->|JIT Compiler|C[Native Code] JIT Compile 과정은 Byte Code 를 Interpreting 하는것보다 많은 비용이 발생하여, 만약 한번만 실행되는 코드라면 Compile 하지 않고 Interpreting 하는것이 훨씬 유리하다. 내부적으로 해당 Method 가 얼마나 자주 수행되고 체크하여 일정 정도의 수준이 넘을때만 Compile 수행 finalize() 객체가 소멸될때 호출되는 메소드일반적으로 GC 에서 객체 메모리를 해지할때 호출되므로 사용이 권장 되지 않는다. "},"book/03.-back-end/01.-java/01.-general/jpa.html":{"url":"book/03.-back-end/01.-java/01.-general/jpa.html","title":"JPA","keywords":"","body":"자바 퍼시스턴스 API (JPA : Java Persistence API) ORM 의 표준 기술로 Hibernate, OpenJPA, EclipseLink, TopLink Essentials 과 같은 구현체가 있고, 이들의 대한 표준 인터페이스 이다. 장점 객체지향적으로 개발 및 데이터를 관리 할 수 있기 때문에 비지니스 로직에 집중할 수 있다. 테이블의 생성, 변경, 관리가 쉽다. 빠른 개발이 가능하다. DB 에 의존적이지 않다. MySQL, Oracle, Sysbase, Derby, PostgreSQL 등등의 데이터 베이스 지원 POJO 기반의 모델의 지원 단점 객체지향을 이해하고 개발 해야 하는 만큼 러닝커브가 높다. 성능상의 문제가 있을수 있다. 참고자료 http://blog.woniper.net/255 "},"book/03.-back-end/01.-java/01.-general/ejb.html":{"url":"book/03.-back-end/01.-java/01.-general/ejb.html","title":"EJB","keywords":"","body":"엔터프라이즈 자바 빈즈 (EJB : Enterprise Java Beans) 서버/클라이언트 구조의 서버 부분에서 자바 프로그램 컴포넌트들을 설정하기 위한 아키텍쳐이다.EJB 네트워크 내의 클라이언트들에 분산되어 있는 프로그램 컴포넌트들을 위한 자바빈즈 기술 위에서 구현된다. 새로운 프로그램 컴포넌트가 추가되거나 또는 변경될 때 마다, 각 개별 컴퓨터를 갱신하지 않고서라도 서버에서 서버의 변화를 통제할 수 있도록 하는 이점을 제공한다. EBJ 컴포넌트들은 다중 응용프로그램에서 재 사용되는 장점을 가지고 있다. EJB 내에는 두가지 종류의 Beans 가 있는데 다음과 같다. 세션 빈즈 (Session Beans) 엔터티 빈즈 (Entity Beans) 지속성을 가지고 있다. 원래의 습성이나 상태를 유지할 수 있다. 참고자료 http://www.terms.co.kr/EJB.htm "},"book/03.-back-end/01.-java/01.-general/oop/":{"url":"book/03.-back-end/01.-java/01.-general/oop/","title":"객체 지향 프로그래밍 (OOP)","keywords":"","body":"객체 지향 프로그래밍 (OOP : Object Oriented Programming) 프로그램이 더 나은 방향으로 나아가기 위한 개발 방법론으로 대표적으로는 다음과 같은 장점을 예를 들수 있다. 모듈단위의 유지보수 및 수정이 가능한 코드의 개발 재사용이 가능한 코드 향상된 코드의 안정성과 유연성 코드에 대한 높은 이해도 이는 아래의 각각의 대표적 특징으로 인해 나타나는 장점들이다. 다형성 (Polymorphism) 하나의 객체를 여러 타입으로 나타내게 하여 다양한 기능으로 이용할 수 있도록 하는것이다.다형성은 코드의 유연하며 재사용이 가능하도록 구현되며 대표적으로 Overloading 과 Overriding 이 있다. 상속 (Inheritance) 기존의 클래스를 재 사용하여 새로운 클래스로 작성하는 것코드를 재사용하여 새로운 클래스로 작성할 수 있으며 다형성을 구현한 것이다. 캡슐화 (Encapsulation) 객체를 내부를 외부에서 접근을 제한함으로써 이를 보호하는 것을 말한다.이는 정보의 은닉화 때문이며 반드시 객체에 사용한 부분만 일부 노출을 하는 인터페이스 역활만을 노출한다. 객체의 동작으로 독립적으로 변경하거나 확장이 가능하여 코드의 가용성과 유지관리가 향상된다.객체가 원하지 않는 방식으로 상호작용 하는것을 방지하여 모듈성을 향상 시킨다. 오버로딩 (Overloading) 같은 이름의 함수를 여러개 정의하고 매개변수의 유형과 개수를 다르게 하여 다양한 유형의 호출에 응답 오버라이딩 (Overriding) 상의 클래스가 가지고 있는 메소드를 하위 클래스가 재 정의 하여 사용하는 것어떤 메소드가 실행될지는 Dynamic Dispatch (동적 디스패치) 가 일어나며 확인 가능하다. Dispatch ? Static Dispatch : 컴파일 시점에서는 알 수 있다.Dynamic Dispatch : 런타임 순간에 알 수 있다. "},"book/03.-back-end/01.-java/01.-general/oop/solid/":{"url":"book/03.-back-end/01.-java/01.-general/oop/solid/","title":"SOLID","keywords":"","body":"Solid 객체지향 4대 특성인 캡슐화, 상속, 추상화, 다형성 등을 이용하여 객체지향 프로그래밍 셜계를 도와주는 원칙들이 있다.이를 SOLID 원칙들이라 하며 자기 자신의 클래스의 응집도를 높이고, 타 클래스의 결합도를 낮추는 High-Cohesion - Loose Coupling 원칙을 객체 지향관점에서 도입한것이다. SOLID 5대 원칙 (객체 지향 설계 5원칙) SRP (Single Reponsibility Principle : 단일 책임의 원칙) OCP (Open Closed Principle : 개방 폐쇄의 원칙) LSP (Liskov Substitution Principle : 리스코프 치환의 원칙) ISP (Interface Segregation Principle : 인터페이스 분리의 원칙) DIP (Dependency Inversion Principle : 의존 역전의 원칙) SRP (Single Reponsibility Principle : 단일 책임의 원칙) 작성된 클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는데 집중 되어야 한다는것 리팩토링 (Refactoring) 을 통하여 해당 책임을 최상의 상태로 분배 OCP (Open Closed Principle : 개방 폐쇄 원칙) 소프트웨어의 구성요소 (컴포넌트, 클래스, 모듈, 함수) 는 확장에는 열려 있고, 변경에는 닫혀 있어야 한다는 의미이다.기존의 구성요소는 수정이 일어나지 말아야 하며, 기존의 구소요소를 쉽게 확장하여 재 사용 가능해야 한다는 뜻이다. 확장 될것과 불변의 속성을 엄격히 구분한다. 두 모듈이 만나는 지점에 인터페이스를 정의한다. 구현에 의존하기보다 정의한 인터페이스에 의존하도록 코드를 작성한다. LSP (Liskov Substitution Principle : 리스코프 치환 원칙) 파생 클래스는 부모타입과 호환이 되어야 한다. 서브타입은 언제나 기반 타입과 호환될 수 있어야 한다. 하위 클래스가 상위 클래스의 역할을 대신할 때 논리적으로 맞아 떨어져야 한다. ISP (Interface Segregation Principle : 인터페이스 분리 원칙) 최소한의 의미에 맞는 인터페이스만 구현해야 한다. 클래스 인터페이스를 통한 분리객체 인터페이스를 통한 분리 DIP (Dependency Inversion Principle : 의존 역전 원칙) 하위 레벨모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 역전현상 참고자료 http://www.nextree.co.kr/p6960/http://limkydev.tistory.com/77http://choipattern.blogspot.com/2013/08/solid.html "},"book/03.-back-end/01.-java/01.-general/oop/solid/srp.html":{"url":"book/03.-back-end/01.-java/01.-general/oop/solid/srp.html","title":"단일 책임의 원칙 (SRP)","keywords":"","body":"단일 책임의 원칙 (SRP : Single Reponsiblity Principle) SOLID 원칙중에서 1번재 원칙으로 단일 책임의 원칙 이라 한다. 소프트웨어의 설계 부품 (클래스, 함수) 는 단 하나의 책임 (기능) 만 가져야 한다. 새로운 요구사항에 대해 프로그램이 영향 받는 부분이 적어야 한다. 다시 말하면 응집도는 높고 결합도는 낮아야 한다 라는 말이다.만약 한 프로그램이 책임(기능을 담당) 지고 있는 부분이 많아지면 클래스 내부의 함수끼리 강한 결합도를 가질수 있는 가능성이 높기 때문에 요구사항의 수정이 발생할 경우 유지보수 비용이 증가한다.따라서 책임 (기능) 을 분리 할 수 있는 구조로 설계되어야 한다. "},"book/03.-back-end/01.-java/01.-general/oop/solid/ocp.html":{"url":"book/03.-back-end/01.-java/01.-general/oop/solid/ocp.html","title":"개방 폐쇄의 원칙 (OCP)","keywords":"","body":"개방 폐쇄의 원칙 (OCP : Open Closed Principle) SOLID 원칙중에서 2번재 원칙으로 개방폐쇄의 원칙이라 한다. 확장 될것과 불변의 속성을 엄격히 구분한다. 두 모듈이 만나는 지점에 인터페이스를 정의한다. 구현에 의존하기보다 정의한 인터페이스에 의존하도록 코드를 작성한다. 정의 소프트웨어의 구성요소 (컴포넌트, 클래스, 모듈, 함수) 는 확장에는 열려 있고, 변경에는 닫혀 있어야 한다. 이는 기존의 구성요소는 수정이 일어나지 말아야 하며, 기존의 구성요소를 쉽게 확장하여 재사용 가능 해야 한다는 뜻이며, 프로그램 설계 과정에서 많은 고민이 되어 있어야 하고 이를 위해 자주 사용되는 문법이 interface 를 활용한 방법이다. 아래 예시를 통하여 OCP 의 위배 사항을 살펴 보자 class SoundPlayer { void play() { System.out.println(\"play wav\"); } } public class Client { public static void main(String[] args) { SoundPlayer sp = new SoundPlayer(); sp.play(); } } 상기 코드에서 play() 를 다른 파일 포맷의 재생을 원한다면 OCP 원칙에 위배된다. 이러한 경우에는 interface 를 구성하여 OCP 를 만족한다. interface playAlgorithm { public void play(); } class Wav implements playAlgorithm { @Override public void play() { System.out.println(\"Play Wav\"); } } class Mp3 implements playAlgorithm { @Override public void play() { System.out.println(\"Play Mp3\"); } } 위와 같이 재생하고자 하는 playAlgorithm 인터페이스의 play() 를 재정의 하도록 설계한다. 이와 같은 설계 방식을 디자인 패턴에서는 전략 패턴 (Strategy Pattern) 이라고 한다. OCP 를 만족한 설계는 다음과 같은 장점이 있다. 변경에 유연하게 대처 가능하다. 유지보수 비용이 감소된다. 코드의 가독성이 높아진다. 참고자료 https://code.tutsplus.com/tutorials/solid-part-2-the-openclosed-principle--net-36600 "},"book/03.-back-end/01.-java/01.-general/oop/solid/lsp.html":{"url":"book/03.-back-end/01.-java/01.-general/oop/solid/lsp.html","title":"리스코프 치환의 원칙 (LSP)","keywords":"","body":"리스코프 치환 원칙 (LSP : Liskov Substitution Principle) SOLID 원칙중에서 3번재 원칙으로 리스코프 치환 원칙 이라고 한다. OCP (Open Close Principle : 개방 폐쇠의 법칙) 과 밀접한 연관이 있으며 OCP 를 바탕으로 구현한 템플릭 설계의 하나의 예라고 할 수 있다.즉 LSP 는 OCP 의 해결책 중 하나이다. 정의 자식 (파생) 클래스는 언제나 부모 (기반) 타입과 호환이 되어야 한다. 하위 클래스가 상위 클래스의 역할을 대신할 때 논리적으로 맞아 떨어져야 한다. 다음 예는 이를 설명하기 위한 가장 유명한 예 이다. graph LR A[\"Rectangle\"] --> B[\"Square\"] 최초에 기반타입을 담당할 Rectagle 클래스를 선언한다. 여기에는 너비와 높이 등이 선언되어 있으며 도형의 넓이를 반환하는 area 함수까지 구현되어 있다. class Rectangle { private int width; private int height; public void setHeight(int height) { this.height = height; } public int getHeight() { return this.height; } public void setWidth(int width) { this.width = width; } public int getWidth() { return this.width; } public int area() { return this.width * this.height; } } Rectangle 클래스를 상속 받는 Square 클래스가 있다. Square 클래스는 정사각형 의 도형 처리를 담당하는 클래스이다. class Square extends Rectangle { @Override public void setHeight(int value) { this.width = value; this.height = value; } @Override public void setWidth(int value) { this.width = value; this.height = value; } } 위의 두개의 클래스를 소비할 메인 함수이다. public class MyClass { static boolean checkAreaSize(Rectangle r) { r.setWidth(5); r.setHeight(4); if (r.area() != 20 ) { throw new RuntimeException(\"Bad Area\"); } return true } public static void main(String[] args) { checkAreaSize(new Rectangle()); checkAreaSize(new Square()); // Error Exception } } 이를 실행하면 두개의 클래스가 전혀 다른 결과를 가져온다. 하나는 Rectangle 클래스는 넓이가 20 으로 연산 되는데 반해 Square 클래스는 오류를 반환한다. 이것이 바로 리스코프의 치환 원칙 을 벗어난 대표적인 예이다. 다시 정리하면 상위 타입의 객체를 하위타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작 해야 한다. 리스코프 치환을 벗어나는 위반사례는 대표적으로 다음과 같다. 명시된 명세에서 벗어난 값 을 반환한다. 명시된 명세에서 벗어난 오류 를 발생한다. 명시된 명세에서 벗어난 기능 을 수행한다. 해결 방법 상속관계를 제거한다. 문제가 되는 area() 를 Square 로 이동한다. LSP 를 통하여 자식 클래스가 상속받은 부모 클래스의 역활을 충실히 하면서 확장 해나가야 한다. 참고자료 https://code.tutsplus.com/tutorials/solid-part-3-liskov-substitution-interface-segregation-principles--net-36710 "},"book/03.-back-end/01.-java/01.-general/oop/solid/isp.html":{"url":"book/03.-back-end/01.-java/01.-general/oop/solid/isp.html","title":"인터페이스 분리의 원칙 (ISP)","keywords":"","body":"인터페이스 분리의 원칙 (ISP : Interface Segregation Principle) SOLID 원칙중에서 4번재 원칙으로 개방폐쇄의 원칙이라 한다. 하나의 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 않아야 한다. 하나의 인터페이스보다는 여러개의 구체적인 인터페이스가 낫다 시스템의 내부 의존성을 약화시켜 리펙토링, 수정, 재배포를 쉽게할 수 있다. "},"book/03.-back-end/01.-java/01.-general/oop/solid/dip.html":{"url":"book/03.-back-end/01.-java/01.-general/oop/solid/dip.html","title":"의존 역전의 원칙 (DIP)","keywords":"","body":"의존 역전의 원칙 (DIP : Dependency Inversion Principle) SOLID 원칙중에서 5번재 원칙으로 의존 역전의 원칙이라 한다. 읜존 관계를 맺을 때, 변화하기 쉬운것 (클래스) 보단 변화하기 어려운 것 (추상클래스, 인터페이스) 에 의존해야 한다는 원칙이다. "},"book/03.-back-end/01.-java/01.-general/design_pattern/":{"url":"book/03.-back-end/01.-java/01.-general/design_pattern/","title":"디자인 패턴 (Design Pattern)","keywords":"","body":"Design Pattern 객체 지향 설계에서 상황에 따른 요구사항의 문제를 빠르게 해결할 수 있도록 설계를 도와준다. Java 에서 대표적으로 사용되는 Design Pattern 은 크게 3가지의 범주로 나뉜다. 생성관련 패턴 객체 인스턴스 생성을 위한 패턴 Singleton (싱글톤) Prototype (프로토타입) 빌더 추상 팩토리 행동관련 패턴 클래스와 객체들이 상호작용하는 방법 및 역활을 분담 Strategy (전략) 옵저버 스테이트 커맨드 이터레이터 템플릿 메소드 인터프리터 미디에이터 역활변경 메멘토 비지터 구조관련 패턴 데토레이터 어댑터 컴포지트 퍼사드 프록시 브릿지 플라이웨이트 클래스와 객체들의 구성을 통해서 더 큰 구조로 확장 가능한 패턴 참고자료 https://brunch.co.kr/@springboot/31 Function Signature (함수 시그니처) 함수 의 원형에 명시되는 매개변수 리스트를 가르킨다. 두 함수의 매개변수의 갯수 와 타입 이 같으면 두 함수의 시그니처는 같다고 할 수 있습니다. int sum (int a, int b, double c); int sum2 (int, int, double); 위 두 함수의 시그니처가 같다.시그니처가 같은 함수는 같은 함수 포인터에 의해 상호호환이 가능하다. 참고자료 https://blog.sapzape.com/330 메서드 시그니처 (Method Signature) 메서드 이름과 매개변수 (Parameter)로 이루어진다. 반환값의 타입은 시그니처에 포함되지 않는다. "},"book/03.-back-end/01.-java/01.-general/design_pattern/strategy.html":{"url":"book/03.-back-end/01.-java/01.-general/design_pattern/strategy.html","title":"전략 패턴 (Strategy Pattern)","keywords":"","body":"Strategy Design Pattern (전략 디자인 패턴) 디자인 패턴의 가장 중요한 패턴으로 다음 3가지의 요소로 구성된다. 전략객체를 가진 전략 객체 public interface Action { void move(); } 전략 객체를 사용하는 컨텍스트 (소비) public class Walking implements Action { @Override public void move() { System.out.println(\"Walking road\"); } } public class Running implements Action { @Override public void move() { System.out.println(\"Running road\"); } } public class Human { void start(Action action) { System.out.println(\"Start Action\"); action.move(); System.out.println(\"End Action\"); } } 전략 객체를 생성해 컨텍스트에 주입하는 클라이언트 (공급) public class Client { public static void main (String[] args) { Human human = new Human(); Walking walk = new Walking(); human.start(walk); Running run = new Running(); human.start(run); } } Start Action Walking road End Action Start Action Running road End Action 클라이언트가 전략을 생성하여 전략을 실행 (소비) 할 컨텍스트에게 주입하는 패턴이다. 템플릿 메소드 패턴과 유사하지만 다양한 전략을 변경하면서 컨텍스트에게 주입할 수 있다. (템플릿 메소드보다 우수) "},"book/03.-back-end/01.-java/01.-general/design_pattern/factory_method.html":{"url":"book/03.-back-end/01.-java/01.-general/design_pattern/factory_method.html","title":"팩토리 메소드 패턴 (Factory Method)","keywords":"","body":"Factory Method Design Pattern (팩토리 디자인 패턴) 직접 객체를 생성하지 않고 팩토리 메서드 클래스에서 객체를 대신 생성시킨다. 장점 유지보수가 용이하다. 참고자료 http://limkydev.tistory.com/83?category=957882 "},"book/03.-back-end/01.-java/01.-general/design_pattern/template_method.html":{"url":"book/03.-back-end/01.-java/01.-general/design_pattern/template_method.html","title":"템플릿 메소드 패턴 (Template Method)","keywords":"","body":"Template Method Design Pattern (템플릿 메소드 디자인 패턴) 상위 추상 클래스가 대략적인 로직을 잡아두고 실제로 상세한 구현은 상속을 받아 구현을 강제하도록 하는것 public abstract class Car { public void playWithOwner() { System.out.println(\"Start\"); play(); runSomeThing(); } abstract void play(); void runSomething() { System.out.println(\"Something\"); } } public class Auto extends Car { @Override void play() { System.out.println(\"move Car\"); } void runSomething() { System.out.println(\"Something others\"); } } public class Main { public static void main(String[] args) { Car auto = new Auto(); auto.playWithOwner(); } } Start move Car Something others 참고자료 http://limkydev.tistory.com/81?category=957882 "},"book/03.-back-end/01.-java/02.-references/":{"url":"book/03.-back-end/01.-java/02.-references/","title":"02. Reference","keywords":"","body":"Reference 마커 인터페이스 (Marker Interface) 메서드 선언이 없는 인터페이스이다. 대표적으로는 Serializable 과 Cloneable 이 있다. 참고자료 https://programmingfbf7290.tistory.com/entry/안드로이드-마커Marker-인터페이스-어노테이션Annotation-활용 "},"book/03.-back-end/01.-java/02.-references/map.html":{"url":"book/03.-back-end/01.-java/02.-references/map.html","title":"Map","keywords":"","body":"Map Key 와 Value 의 형태로 데이터를 관리한다. graph LR A[\"Map\"] --> B[\"HashMap\"] A --> C[\"Hashtable\"] A --> D[\"Sorted Map\"] D --> E[\"Tree Map\"] HashMap HashMap 은 Map 인터페이스 계열의 대표적인 클래스이며 get, put 등의 메서드를 사용하여 데이터를 관리한다. HashMap 계열은 각각의 특징에 따라 아래와 같인 차이점으로 나뉜다. HashMap 동기화 보장이 안된다. (Thread-not-safe) Key & Value 에 Null 허용 Hashtable 동기화 보장이 된다. (Thread-safe : 멀티스레드 환경에서 안정적) Key & Value 에 Null 허용 불가 TreeMap 정렬 기능을 지원함 Hashtable & ConcurrentHashMap HashMap 을 thread-safe 하도록 만든 클래스가 ConcurrentHashMap 이며, key & value 에 null 을 허용하지 않는다.둘 다 동기화 보장을 하는 특징이 있지만 구조적으로 작은 차이가 있다. Hashtable synchronized 키워드를 Method 전체에 Lock 을 적용한다. 상대적으로 안정하지만 확장성이 떨어진다. Hashtable 을 참조하는 Thread 의 갯수가 많아질수록 Lock 을 획득하기 위한 시간비용이 많이 들어 성능이 급격히 낮아진다. ConcurrentHashMap 내부적으로 여러개의 세그먼트를 두고 각 세그먼트마다 별도의 락을 가지고 있다. 동시에 데이터를 삽입, 참조 하더라도 그 데이터가 다른 세그먼트에 위치하면 서로 Lock 을 얻기 위해 경쟁하지 않는다. 이러한 방식을 Lock Striping 이라고 한다. Key & Value 에 Null 허용 불가 참고자료 http://egloos.zum.com/Agbird/v/4849046 HashMap 의 동작 과정 Java 에서의 HashMap 은 Key & Value 를 쌍으로 저장한다.이는 Hash 함수를 필요로 hashCode 를 통하여 값을 저장하고 불러내는 과정을 거친다. HashMap 과 HashTable 은 Map 인터페이스를 구현하고 있기 때문에 HashMap 과 HashTable 의 제공하고 있는 기능은 거의 같다.다만 HashMap 은 보조해시함수 (Additional Hash Function) 를 사용하고 있기 때문에 보조 해시함수를 사용하고 있지 않는 HashTable 에 비하여 해시 충돌 (Hash Colision) 이 덜 발생하고 있어 상대적으로 성능상의 이점을 보인다. 보조 해시 함수 저장하려는 두 개가 같은 인덱스로 해싱 (hashing : hash 함수를 통해 계산됨을 의미) 하게 되면 같은곳에 저장할 수 없게 된다.때문에 해싱된 인덱스에 이미 다른 값들이 들어있다면 데이터를 저장할 다른 위치를 찾은뒤에야 저장할 수 있다. 해시 충돌을 회피하는 방법들은 다음과 같다. 개방 주소법 (Open Address) 해시충돌이 발생하면 다른 버킷 (데이터 주소 공간) 을 찾아 자료를 삽입하는 방식 비어있는 버킷을 탐색하거나 혹은 2차 해시함수를 이용하여 새로운 주소를 할당한다. 분리 연결법 (Seperate Chaining) ?????????? 이 외에도 해시 버킷의 동적 확장 등과 같은 방법도 있다. 참고자료 https://asfirstalways.tistory.com/332https://d2.naver.com/helloworld/831311 "},"book/03.-back-end/01.-java/02.-references/collection/":{"url":"book/03.-back-end/01.-java/02.-references/collection/","title":"Collection","keywords":"","body":"Collection Java Collection Framework (JCF) Java 에서 데이터를 저장하는 기본적인 자료구조들을 한곳에 모아 관리하고 편하게 사용하기 위해서 제공하는 것JCF 의 상속 구조이며 사용용도에 따랄 List Set Map 으로 나뉜다. 모든 콜렉션의 상위 인터페이스로써 콜렉션들이 갖고 있는 핵심 메소드를 선언 (add, contain, isEmpty, remove, size, iterator ...) 인터페이스 구현체(클래스) 특징 List LinkedListStackVectorArrayList 순서가 있는 데이터의 집합 Set HashSetTreeSet 순서를 유지하지 않는 집합데이터의 중복이 허용되지 않는다. Map HashMapTreeMapHashTableProperites 키 와 값의 쌍으로 이루어진 데이터 집합이며 순서를 유지하지 않는 집합이다.데이터의 중복이 허용되지 않지만 값의 중복은 허용한다. 참고자료 http://hackersstudy.tistory.com/26 Collection 인터페이스를 상속 받은 구현체 List 와 Set 을 기준으로 나뉜다. graph LR A[\"Collection\"] --> B[\"List\"] B --> D[\"Linked List\"] B --> E[\"Stack\"] B --> F[\"Array List\"] B --> G[\"Vector\"] A --> C[\"SET\"] C --> H[\"Hash Set\"] C --> I[\"Sorted Set\"] I --> J[\"Tree Set\"] K[\"Map\"] --> L[\"Hashtable\"] K --> M[\"HashMap\"] K --> N[\"SortedMap\"] N --> O[\"TreeMap\"] 참고자료 http://withwani.tistory.com/150https://www.toolsqa.com/java/data-structure/ "},"book/03.-back-end/01.-java/02.-references/collection/list.html":{"url":"book/03.-back-end/01.-java/02.-references/collection/list.html","title":"List","keywords":"","body":"List 순서가 있는 Collectaion (삽입된 순서)Data 를 중복해서 포함할 수 있다. graph LR B[\"List\"] --> D[\"Linked List\"] B --> E[\"Stack\"] B --> F[\"Array List\"] B --> G[\"Vector\"] Linked List Stack 후입선출 (LIFO : Last-In First-Out) 구조로 되어 있다. ArrayList 동기화를 보장하지 않는다. 배열의 동적 메모리 증가 기능을 구현한 클래스 Vector 자동으로 동기화를 보장해 준다. ArrayList 의 동기화가 보장되도록 최적화한 클래스 JDK 5.0 이후부터 Auto Boxing / UnBoxing 기능을 지원 Tree Set 정렬 기능을 지원 (데이터들이 자동으로 오름차순으로 정렬) AutoBoxing 기본 데이터 타입을 Wrapper 클래스형의 객체로 자동 변환해주는 기능 Array & ArrayList 의 차이점 Array ArrayList Resize 여부 고정크기 가변크기 ArrayList 와 LinkedList 의 차이점 ArrayList LinkedList 데이터 구조 인덱스 기반 이전과 다음 요소를 가르키는 포인터 기반 "},"book/03.-back-end/01.-java/02.-references/collection/set.html":{"url":"book/03.-back-end/01.-java/02.-references/collection/set.html","title":"Set","keywords":"","body":"Set 집합적인 개념의 Collection순서의 의미가 없다.Data 를 중복해서 포함할 수 없다. graph LR C[\"SET\"] --> H[\"Hash Set\"] C --> I[\"Sorted Set\"] Hash Set Hash 기법을 사용하지만 Set 인터페이스를 구현하고 있다. Sorted Set 정렬 기능을 지원함 "},"book/03.-back-end/01.-java/02.-references/thread/":{"url":"book/03.-back-end/01.-java/02.-references/thread/","title":"Thread","keywords":"","body":"THREAD Process & Thread 의 차이 프로세스와 스레드는 서로 밀접한 관계에 있으나 서로 다른 개체이다. Process 실행중인 프로세스 객체 CPU 시간이나 메모리 등의 시스템 자원이 할당되는 독립적인 개체 각 프로세스는 별도의 주소 공간에서 실행 되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없음 같은 메모리를 읽고 쓰는 프로세스는 생성 가능 프로세스간의 통신은 Pipe, Socket, File 등으로 통신한다. Thread 프로세스가 할당받은 자원을 이용하는 실행의 단위 프로세스와 같은 공간의 Stack 공간을 사용하며 여러 Thread 는 그 상태의 일부를 공유한다. Multi Thread 환경의 작업시에는 Therad 간의 자원 공유의 동기화 문제 에 신경을 써야 한다. 구조 @TODO 생명주기 @TODO 생성방법 아래와 같이 크게 3가지 방법이 있다. Thread 클래스를 확장 한다. Runnable 인터페이스를 구현 Thread Pool 을 생성하기 위해, 어플리케이션에서 Executor 프레임워크를 사용한다. 'Runnable' 인터페이스는 상속 객체를 필요로 하지 않기 때문에 인터페이스로 적절하다. 이러한 방법들은 대부분 멀티스레드를 만들어 작업을 수행하는 과정으로여기서 자세한 방법들을 소개한다. Thread 상태 NEW : Thread 가 실행 준비가 되었습니다. RUNNABLE : JVM (Java Virtual Machine) 이 Thread 코드를 수행중입니다. BLOCKED : Thread 가 차단되어 있는 상태 입니다. WAITING : Thread 다른 Thread 의 작업이 수행되기를 기다립니다. TIMED_WAITING : Thread 가 다른 Thread 의 지정된 대기시간의 특정 작업을 수행하기까지 기다립니다. TERMIATED : Thread 의 실행을 완료했습니다. "},"book/03.-back-end/01.-java/02.-references/thread/synchronized.html":{"url":"book/03.-back-end/01.-java/02.-references/thread/synchronized.html","title":"Synchronized","keywords":"","body":"동기화 (Synchronizred) Java 에서 동기화 영역은 synchronizred 키워드로 표시된다. 동기화는 객체에 대한 동기화로 이루어지는데 여러 Thread 가 한 개의 자원을 사용하고자 할 때 해당 Thread 만 제외하고 나머지 Thread 의 접근을 막는 방법이다.블록에 접근을 시도하는 다른 Thread 들은 블록 안의 Thread 가 실행을 마치고 블록을 벗어날때까지 차단 (blocked) 상태 가 된다. 대표적으로 Log Files 과 같이 서로 다른 프로세스에 접근 가능한 리소스를 대상으로 사용할때 효과적이다. 이러한 방식을 배타적 접근 이라고 한다. 장점 thread-safe 하게 사용이 가능하여 사용자의 의도대로 프로그램의 흐름 제어가 가능하다. 단점 프로그램의 성능저하를 일으킬 수 있다. Java 내부적으로 메서드나 변수에 동기화를 하기 위해 block & unblock 처리를 하게되는데 이런 처리들을 통하여 소비되는 리소스가 프로그램 전반적인 성능에 영향을 준다. synchronized 키워드는 다음 네가지 유형의 블록이 쓰인다. Syntax 인스턴스 메소드에 동기화 적용 (Instance Method) 특정 부분에 대해서만 동기화를 동기화를 할 필요가 있을 경우 아래 메소드와 같이선언문에 있는 synchronized 키워드를 통하여 동기화를 한다. public synchronized void add(int value) { this.count += value; } Instance Method 의 동기화는 이 Method 를 가진 Instance (객체) 를 기준 으로 한다.하나의 Class 가 동기화된 Instance Method 를 가지면, 동기화는 이 Class 의 하나의 Instance 를 기준으로 이루어지며 한 시점에 오직 하나의 Thread 만이 동기화된 Instance Method 를 실행할 수 있다. 하나의 Instance 하나의 Thread 이다. 정적 메소드에 동기화 적용 (Static Method) 인스턴스 메소드의 사용법과 같이 선언문에 있는 synchronized 키워드를 통하여 동기화를 한다. public static synchronized void add(int value) { count += value; } Static Method 의 동기화는 이 Method 를 가진 Class (객체) 를 기준 으로 한다.JVM 안에 Class 객체는 Class 당 하나만 존재할 수 있으므로, 같은 Class 에 대해서는 오직 한 Thread 에만 동기화된 Static Method 를 실행할 수 있다. 하나의 Class 당 하나의 Thread 이다. 인스턴스 메소드 안에 동기화 적용 (Instance Method Codeblock) 동기화를 메소드 전체에 적용하는것이 아닌 메소드의 특정 부분에 적용하는것이 효율적일 때가 있다. public void add(int value) { synchronized(this) { this.count += value; } } 정적 메소드에 안에 동기화 적용 (Static Method Codeblock) Instance Method Codeblock 과 사용법은 동일하다. public static void add(int value) { synchronized(this) { this.count += value; } } 참고자료 http://parkcheolu.tistory.com/15 "},"book/03.-back-end/01.-java/02.-references/thread/multi_thread.html":{"url":"book/03.-back-end/01.-java/02.-references/thread/multi_thread.html","title":"Multi Thread","keywords":"","body":"멀티 스레드 (Multi Thread) Java 에서는 Multi Thread 환경을 만들어 사용하는 방법은 대표적으로 3가지 방법을 많이 사용한다. Thread Class 를 상속받아 사용 Thread Class 를 서브클래싱(subclassing) 하고 run Method 를 Override 한다. 구현 순서 Thread Class 를 상속 받아 내가 시킬 일을 해줄 Class 를 하나 만든다. 위에서 만든 Class 에 run Method 안에 시킬 일을 정의해 준다. 메인 Thread 에서 위에서 만는 Class 의 start Method 를 호출한다. 반드시 start 메소드로 실행을 해야 한다.run 메소드를 실행하면 메인 Thread 에서 돌아가므로 의미가 없다. static class AddThread extends Thread { @Override public void run() { int sum = 0; for (int i = 1; i AddThread at = new AddThread(); at.start(); Runnable 인터페이스를 구현하여 사용 Runnable 인터페이스를 구현하고 Runnable 객체를 Thread 생성자로 전달한다. 구현순서 우선 Runnable Interface 를 구현할 Class 를 하나 생성한다. 위에서 만든 Class 의 run Method 에 시킬 일을 정의한다. 해당 Class 를 생성하고 Thread 를 생성할 때 인자로 넣어서 생성한다. 메인 Thread에서 위에서 만든 Class 의 start Method 를 호출한다. static class AddThreadRunnable implements Runnable { @Override public void run() { int sum = 0; for (int i = 1; i Runnable ar = new AddThreadRunnable(); Thread atr = new Thread(ar); atr.start(); Thread 가 할 일을 run Method 안에 넣으면 된다. Single Thread 프로그램은 main Method 가 반환되면 종료되고Multi Thread 프로그램은 run Method 의 실행이 끝나면 종료된다. Future, Callable, Executor Java 5 이상에서 지원하는 방식으로 Callback Pattern 으로 쉽게 사용 가능하도록 하는 접근 방법이다. 다양한 종류의 Thread 를 생성한 다음, 여러 Thread 로 부터 원하는 순서대로 값을 얻어올 수 있다. 구현 순서 작업 대상의 Callable 객체를 생성한 후 ExecutorService 에 등록한다. 작업의 결과는 Future 객체가 반환 받는다. Future 객체 사용 시 이미 결과가 준비 되어 있는 경우에는 즉시 사용하며, 그렇지 않는 경우에는 Polling Thread 는 준비가 될 때까지 Block 상태가 된다. 참고자료 https://post.naver.com/viewer/postView.nhn?volumeNo=7852076&memberNo=30800755 "},"book/03.-back-end/01.-java/02.-references/functional/":{"url":"book/03.-back-end/01.-java/02.-references/functional/","title":"함수형 프로그래밍","keywords":"","body":"함수형 프로그래밍 (Functional Programming) JDK 8 (Java Development Kit 8) 에서 제공하는 새로운 인터페이스들과 기능들을 다룬다. 람다 표현식 (Lamda Expression) Java 8 에서 지원하는 람다 표현식은 고차함수를 이용하여 더 쉽게 프로그래밍 할 수 있다. Exmaple List numbers = Arrays.asList(1, 2, 3, 4, 5, 6); Case 1 : 기존 방식 모든 수를 합치기 public int sumAll(List numbers) { int total = 0; for (int number : numbers) { total += number; } return total; } 짝수만 더하기 public int sumEven(List numbers) { int total = 0; for (int number : numbers) { if (number % 2 == 0) { total += number; } } return total; } Case 2 : 람다 표현식을 이용 public int sumAll(List numbers, Predicate p) { int total = 0; for (int number : numbers) { if (p.test(number)) { total += number; } } return total; } 내부에서 함수형 인터페이스인 Predicate 의 인자를 받아 결과를 인자로 반환하는 고차함수의 방식 을 사용한다. (JS 의 일급객체의 속성과 유사함) 참고자료 https://gist.github.com/ihoneymon/3a98ea468766d6ff3678 // 모든수를 더함 sumAll(numbers, n -> true); // 짝수만 더함 sumAll(numbers, n -> n % 2 == 0); // 홀수만 더함 sumAll(numbers, n -> n % 2 == 1); 참고자료 http://cyberx.tistory.com/55http://cyberx.tistory.com/79 "},"book/03.-back-end/01.-java/02.-references/class/":{"url":"book/03.-back-end/01.-java/02.-references/class/","title":"Class","keywords":"","body":"Class "},"book/03.-back-end/01.-java/02.-references/class/immutable.html":{"url":"book/03.-back-end/01.-java/02.-references/class/immutable.html","title":"Immutable","keywords":"","body":"Immutable Class (불변 객체) 생성후 변경 불가능한 객체로서 대표적으로 String, Boolean, Integer, Float, Long 등등이 있다. HEAP 영역에서의 값이 바뀌는건 아니다. String vs StringBuffer String 은 Immutable 이고 StringBuffer 는 아니다. 이는 객체를 새로 생성할 필요가 없는 StringBuffer 가 더 빠르다는 이야기이다. StringBuffer b = new StringBuffer(); StringBuffer a = b.append(\"test\"); System.out.println(a == b); // true 참고자료 https://hashcode.co.kr/questions/727/자바에서-immutable이-뭔가요 "},"book/03.-back-end/01.-java/02.-references/class/autocloseable.html":{"url":"book/03.-back-end/01.-java/02.-references/class/autocloseable.html","title":"AutoCloseable","keywords":"","body":"AutoCloseable 파일 또는 소켓 핸들 등의 자원들을 종료할 때까지 보관하는 객체이다.AutoCloseable 객체의 close 메소드는 try-with-resources 블럭을 종료할 때 자동으로 호출 된다. 이 구조는 리소스의 고갈 및 다른 예외들까지 발생할 수 있는 에러들의 해소를 즉각적으로 보장한다. try-with-resource 구문과 같이 사용한다. public class MyResource implements AutoCloseable { public void close() throws Exception { System.out.println(\"Closeing!\"); } } try (MyResource res = new MyResource()){ // use the code } 참고자료 https://hyoj.github.io/blog/java/basic/java7-autocloseable.html#method-summary "},"book/03.-back-end/01.-java/02.-references/method/":{"url":"book/03.-back-end/01.-java/02.-references/method/","title":"Method","keywords":"","body":"Method instanceof 참조변수가 참조하는 인스턴스의 실제 타입을 알아보기 위해 사용 class Car { String color; int door; } class Sedan extends Car { void driveSedan() { System.out.println(\"Start Sedan\"); } } class SportsCar extends Car { void driveSportCar() { System.out.println(\"Start Sports Car\"); } } Sedan sedan = new Sedan(); SportsCar sportsCar = new SportsCar(); isCar(sedan); isCar(sportsCar); void isCar(Car car) { if (car instanceof Sedan) { Sedan s = (Sedan) car; s.driveSedan(); } else if (car instanceof SportsCar) { SportsCar p = (SportsCar) car; p.driveSportCar(); } } 결과 // Start Sedan // Start Sports Car 참고자료 https://arabiannight.tistory.com/entry/301 "},"book/03.-back-end/01.-java/02.-references/method/exception.html":{"url":"book/03.-back-end/01.-java/02.-references/method/exception.html","title":"Exception","keywords":"","body":"Exception Java 에서는 기본적으로 2가지의 에러 유형이 있다. Checked Exception Checked Exception 는 외부 환경에 의해 미리 예상 되는 오류이다. 예를 들면 IOException ClassNotFoundException 등과 같이 반드시 예외처리가 필요하다. IOException SQLException Unchecked Exception (Runtime Exception) Unchecked Exception 는 프로그램 로직상의 문제로 일어나는 로직상의 오류로써 미리 예상할 수 없다. 대표적으로 RuntimeException 과 같이 프로그램 실행중에 일어나며 반드시 예외처리를 필요로 하지 않는다. NullPointerException IllegalArgumentException IndexOutOfBoundException SystemException 예외처리한 객체는 작업이 끝난후 모드 GC 의 대상이 된다. Checked Exception Unchecked Exception 처리여부 반드시 예외처리가 필요 명시적인 처리를 강제하지 않음 확인시점 컴파일 단계 실행단계 예외 발생 시트랜잭션 여부 roll-back 하지 않음 roll-back 처리 대표적인 예외 Exception 의 상속을 받는 하위 클래스 중Runtime Exception을 제외한 모든 예외 Runtime Exception 의 하위 예외 클래스 참고자료 http://www.nextree.co.kr/p3239/ "},"book/03.-back-end/01.-java/02.-references/method/generic/":{"url":"book/03.-back-end/01.-java/02.-references/method/generic/","title":"Generic","keywords":"","body":"제네릭 (Generic) Syntax public 리턴타입 메소드명 (매개변수, ...) { /* statement */ } 제네릭 타입의 이름 아무 문자열이나 사용가능하지만 가독성을 위해 일반적으로 다음 규칙을 따른다. 키 설명 E 요소(Element) K 키(Key) N 숫자(Number) T 타입(Type) V 값(Value) S, U, V 두번째, 세번째, 네번째에 선언된 타입 참고자료 https://onsil-thegreenhouse.github.io/programming/java/2018/02/17/java_tutorial_1-21/ "},"book/03.-back-end/01.-java/02.-references/method/reflection.html":{"url":"book/03.-back-end/01.-java/02.-references/method/reflection.html","title":"Reflection","keywords":"","body":"Reflection 리플렉션이란 객체의 클래서 정보를 분석해 내는 프로그램 기법을 말한다. reflection 의 사전적인 의미투영 및 반사입니다. 이는 실행중인 자바 프로그램의 내부를 검사하고 그 속성을 수정할 수 있도록 한다. 쉽게 말해 객체를 통하여 클래스의 정보를 역으로 분석해내는 프로그래밍 기법 을 말한다. Class aClass = Test.class; Class myObjClass = Class.forName(className); Package pkgOfAClass = aClass.getPackage(); 사용 동적으로 로딩하고 동적으로 실행하고 싶을때 주로 사용된다. 재사용성, 확장성, 생산성, 유연성 등이 극대화될 수 있는 곳이여야 효과적이다. 이슈 Runtime 시에 동적으로 원하는 라이브러리를 로딩할 수 잇는 장점이 있지만컴파일시에 탐색 (Detection) 이 안되어 Runtime Exception 이 생길수 있는 단점이 존재 한다. 보통은 동적로딩이 느리다고 전해진다 (확인불가) 참고자료 https://gyrfalcon.tistory.com/entry/Java-Reflectionhttps://asfirstalways.tistory.com/221 "},"book/03.-back-end/01.-java/02.-references/method/static-factory-method.html":{"url":"book/03.-back-end/01.-java/02.-references/method/static-factory-method.html","title":"정적 팩토리 메소드","keywords":"","body":"정적 팩토리 메소드 (Static Factory Method) 기본적으로 Class 의 Instance 를 얻는 전통적인 수단은 public 생성자이다. 클래스는 생성자와 별도로 정적 팩토리 메서드 (static factory method) 를 생성할 수 있다. 사용 class Character() { int strength, dexterity, consitution, intelligence; public Character(int strength, int dexterity, int consitution, int intelligence) { this.strength = strength; this.dexterity = dexterity; this.consitution = consitution; this.intelligence = intelligence; } public static Character newWarrior() { return new Character(15, 5, 10, 3); } public static Character newMage() { return new Character(3, 10, 5, 15); } } Character warrior = Character.newWarrior(); Character mage = Character.newMage(); 위 코드는 정적 팩토리 메서드를 호출할 때 마다 new 연산을 하게 되는데immutable 객체를 캐시해서 쓰고 있거나 혹은 아래와 같이 singleton design pattern 을 이용하여 사용도 가능하다. class Person { private final Person p = new Person(); public static Person getInstance() { return this.p; } } 아래와 같이 리턴하는 클래스의 타입을 유연하게 지정가능하다. class OrderUtil { public static Discount createDiscountItem(String code) throws Exception { if (!isValidCode(code)) { throw new Exception(\"Wrong discount code !!\"); } if (isCoupon(code)) { return new Coupon(1000); return new Point(500); } } } class Coupon extends Discount { ... } class Point extends Discount { ... } 단점 상속을 하려면 public 이나 protected 생성자각 필요하니 정적 팩토리 메서드만 지원하면 하위 클래스를 만들수 없다. 정적 팩토리 메서드는 프로그래머가 찾기 어렵다. 암묵적으로 대표적인 명명 규칙들에 의해 메서드 네이밍을 하는것이 일반적이다. from, of, valueOf, instance, getInstance, create, getType ... 관련출처 Effective Java 3rdhttps://johngrib.github.io/wiki/static-factory-method-pattern/https://mommoo.tistory.com/53 "},"book/03.-back-end/01.-java/03.-performance/":{"url":"book/03.-back-end/01.-java/03.-performance/","title":"03. Performance","keywords":"","body":"Performance String / StringBuffer / StringBuilder 의 사용 문자열을 더하는 식에는 string 보다는 stringBuffer 나 stringBuilder 을 사용해야 한다. string 은 새로운 값을 할당할 때마다 새로 생성되기 때문 (클래스의 메모리 참조 주소가 바뀜) stringBuffer 나 stringBuilder 는 값을 메모리에 append 하는 방식으로 클래스를 별도로 생성하지 않는다. stringBuilder 는 변경 가능한 문자열로 synchronization 이 적용되지 않는다. stringBuffer 는 멀티쓰레드 환경에서 안정적 이다. try-finally 보다는 try-with-resources 를 사용 (Java 7) 향샹된 예외처리문으로 입출력 처리시 예외가 발생하면 JVM 이 자동으로 close 메소드를 호출하여 자원을 반납시켜 줍니다. 이때 try() 구문안에는 AutoCloseable 인터페이스를 구현한 객체여야 한다. public class MyResource implements AutoCloseable { public void close() throws Exception { System.out.println(\"Closeing!\"); } } try (MyResource res = new MyResource()){ // use the code } AutoCloseable Class 는 별도의 문서를 참고하도록 한다. "},"book/03.-back-end/01.-java/03.-performance/gc.html":{"url":"book/03.-back-end/01.-java/03.-performance/gc.html","title":"Garbege Collector","keywords":"","body":"가비지 콜렉터 (GC : Garbege Collector) 가비지 객체 선정 Java GC 는 객체가 가비지 객체인지 판별하기 위해서 reachability 라는 개념을 사용한다.이는 유효한 참조가 있으면 reachable 로, 없으면 unreachable 로 구별하고 unreachable 객체를 가비지로 간주하여 GC 를 수행한다. 서로 참조하고 있는 객체들을 참조 사슬 이라고 하며 최조의 참조가 이루어져 있는 객체의 참조를 Root Set 이라고 한다. 아래는 런타임 데이터 영역의 구조이다. Reachability Heap 영역에 있는 객체들에 대한 참조는 다음 4가지중에 하나이다. Heap 영역 내에 있는 다른 객체에 의한 참조 Java Stack (Java Method 실행시 사용하는 지역변수 및 파라메터들에 의한 참조) Native Stack (JNI에 의해 생성된 객체에 대한 참조) 메서드 영역의 정적 변수에 의한 참조 이들 중 Heap 내의 다른 객체에 의한 참조를 제외한 나머지 3개가 Root Set 이 되므로 reachability 객체를 판가름 하는 기준이 된다. 이를 적용한 구성은 다음과 같다. Root Set 에서 시작한 참조 사슬에 속한 객체들은 reachable 객체이고 이와 무관한 객체들을 unreachable 객체로 GC 대상이다. 오른쪽 아래 객체처럼 reachable 객체를 참조하더라도, 다른 reachable 객체가 이 객체를 참조하지 않는다면 이 객체는 unreachable 객체이다. (이 그림에서 참조는 모두 java.lang.ref 패키지를 사용하지 않은 일반적인 참조이다.) 위 구성을 strong reference 라 부른다. Reference Object java.lang.ref 는 soft, weak, phantom reference 를 클래스 형태로 제공한다. java.lang.ref.WeakReference 클래스는 참조 대상인 객체를 캡슐화한 WeakReference 객체를 생성한다.이렇게 생성한 객체는 Java GC 의 별도 관리 대상이 된다. (캡슐화된 내부 객체는 weak reference 에 의해 참조된다.) WeakReference wr = new WeakReference(new Sample()); Sample ex = wr.get(); 위 코드에서 WeakReference 클래스의 객체는 new 메서드로 생성된 Sample 객체를 캡슐화한 객체이다.참조된 Sample 객체는 두번째 줄에서 get 메서드에 의해 다른 참조에 대입된다. 이 시점에서 WeakReference 객체 내의 참조와 ex 참조가 Sample 객체를 가르킨다. ex = null; 위 코드와 같이 ex 참조에 null 을 대입하면 처음 생성한 Sample 객체는 오직 WeakReference 내부에서만 참조된다. 이를 weakly reachable 상태 객체 라고 한다. Reference Object Java 스팩에서 SoftReference, WeakReference, PhantomReference 3가지 클래스로 생성된 객체를 말한다. Reference Object 에 의해 참조된 객체를 referent 라고 한다. Reference와 Reachability 위에서 GC 대상여부를 reachable, unreachable 로 구분하였으며java.lang.ref 패키지를 이용하여 GC 때의 동작을 다르게 지정가능하게끔 개입 할 수 있다.이를 다음과 같이 표현 가능하다. 파랑 : Strongly Reachable Object 녹색 : Weakly Reachable Object (GC 대상) 빨강 : Unreachable Object (GC 대상) 위 그림에서 WeakReference 객체 자체는 weakly reachable 객체가 아니라 strongly reachable 객체이다.또한 WeakReference 에 의해 참조되고 있으면서 동시에 root set 에서 시작한 참조사슬에 포함되어 있는 경우 weakly reachable 객체가 아니라 strongly reachable 객체이다. GC가 동작하여 어떤 객체를 weakly reachable 객체로 판명하면,GC는 WeakReference 객체에 있는 weakly reachable 객체에 대한 참조를 null 로 설정한다. 이에 따라 weakly reachable 객체는 unreachable 객체와 마찬가지 상태가 되고,가비지로 판명된 다른 객체들과 함께 메모리 회수 대상이 된다. Strengths of Reachability Java GC 는 위에서 말한 근거를 바탕으로 다음 5가지의 Reachability 를 결정한다. Strongly Reachable root set 으로 부터 시작해서 어떤 reference object 도 중간에 끼어 있지 않는 상태 객체까지 도달하는 여러 참조사슬중에 reference object 가 하나라도 없는 객체 Softly Reachable Strongly Reachable 객체가 아닌 객체중에 weak reference, phantom reference 없이 sort reference 가 하나라도 있는 객체 Weakly Reachable Strongly Reachable 나 Softly Reachable 객체도 아닌 객체중에서 phantom reference 없이 weak reference 만 통과하는 참조 사슬이 하나라도 있는 객체 Phantomly Reachable Strongly Reachable 나 Softly Reachable, Weakly Reachable 객체 모두 해당되지 않는 객체 finalize 되었지만 아직 메모리가 회수되지 않는 상태 Unreachable root set 으로 부터 시작되는 참조 사슬이 참조되지 않는 상태 아래 예시의 객체 B 는 Softly Reachable 이다. 참고자료 https://d2.naver.com/helloworld/329631 영역 구성 GC 를 실행하기 위해 stop-the-world 을 이용하여 모든 애플리케이션 작업을 멈춘다.이 stop-the-world 를 실행하면 GC 를 실행하는 thread 를 제외한 나머지 thread 는 모두 작업을 멈춘다. GC 작업을 완료한 이후에는 중단됬던 작업을 다시 시작한다. JAVA 프로그램 코드에서는 메모리를 명시적으로 지정하여 해제하지 않는다.이는 Garbage Collector 의해 더 이상 필요없는 객체를 찾아 지우는 작업을 한다. 이 Garbage Collector 의 설계 원칙은 weak generational hypothesis 이라고 하는데 이 원칙은 다음과 같다. 대부분의 객체는 금방 접근 불가능한 상태 (unreachable) 상태가 된다. 오래된 객체에서 젊은 객체로서의 참조는 극히 드물다. 위 두 가설을 기반으로한 HotSpot VM 에서는 크게 2개의 물리적 공간을 나뉘었다.바로 아래와 같은 Old Generation Area, Young Generation Area 이다. Young Generation Area 새롭게 생성한 객체가 위치하는 공간 대부분의 객체가 금방 접근 불가 상태가 되기 때문에 많은 객체가 Young 에서 생성되었다가 사라진다 이 영역에서 객체가 사라질때 Minor GC 가 발생한다. Old Generation Area 접근 불가능 상태로 되지 않아 Young 영역에서 살아남은 객체가 여기로 복사된다. 대부분의 Young 영역보다 크게 할당하며, Young 영역 보다는 GC 가 적게 발생한다. 이 영역에서 객체가 사라질때 Major GC (혹은 Full GC) 가 발생한다. Permanent Generation Area 객체나 억류된 문자열 정보를 저장하는 곳 이 영역에서 객체가 사라질때 Major GC 가 발생한다. Old 영역에서 Young 영역 참조가 일어날때는 Card Table 이라는 영역을 사용한다. Young 영역 구성 Young 영역은 다음 3개의 영역으로 구성된다. Eden Area (1개) Suvivor Area (2개) 새로 생성한 대부분의 객체는 Edan 영역에 위치한다. Edan 영역에서 GC 가 한번 발생한 후 살아남은 객체는 Survivor 영역 중 하나로 이동된다. 하나의 Survivor 영역이 가득 차게되면 그중 살아남은 객체를 다른 Survivor 영역으로 이동하고 가득찬 Survivor 영역은 아무데이터도 없는 상태가 된다. 이 과정을 반복하며 살아남은 객체는 Old 영역으로 이동하게 된다. Survivor 영역 중 하나는 반드시 비어있는 상태로 남아 있어야 한다. 만약 두 Survivor 영역이 모두 데이터가 존재하거나, 두개의 Survivor 영역의 사용량이 0 이라면 시스템은 정상적인 상황이 아니다. HotSpot VM 의 메모리 할당 기술 Young 영역에는 객체의 이동이 빈번하기 때문에 개선된 메모리 할당 기술이 필요하다.다음은 HotSpot VM 에서 사용중인 2가지의 메모리 할당 기술이다. bump-the-pointer Eden 영역에 할당된 마지막 객체를 추적한다. 마지막 객체는 TOP 에 위치하고 있기 때문에 삽입하려는 객체의 크기가 Eden 영역에 넣기에 적당한지 확인하여 추가한다. 새로운 객체를 생성할때 마지막에 추가된 객체만 점검하면 되므로 매우 빠르게 메모리 할당이 이루어진다. TLABs (Thread Local Allocation Buffers) Multi Thread 환경에서 Tread-Safe 하기 위해서 Edan 영역에 Lock 이 발생 할수 밖에 없는데 이를 해결하기 위해서 HotSpot VM 에서 지원하는 TLABs 기술이 있다. Old 영역의 GC Old 영역은 데이터가 가득차면 GC 를 실행한다.다음 GC는 JDK 7 기준의 5가지 방법이다. Serial GC CPU 코어 개수가 적을 때 적합 Parallel GC 메모리와 CPU 코어 개수가 많을 때 유리 Parallel Old GC (Parallel Compacting GC) Concurrent Mark & Sweep GC (CMS) 애플리케이션 응답이 중요한 경우 사용 (Low Latency GC) 다른 GC 에 비해 메모리와 CPU 를 더 많이 사용 다른 GC 에 비해 산재된 메모리가 많을수 있기 때문에 stop-the-world 시간이 더 길다. G1 (Garbage First) GC 가장 최신의 가장 성능이 좋은 GC (JDK 7 이상) 참고자료 https://d2.naver.com/helloworld/1329 "},"book/03.-back-end/01.-java/03.-performance/anti-pattern.html":{"url":"book/03.-back-end/01.-java/03.-performance/anti-pattern.html","title":"Anti Pattern","keywords":"","body":"안티 패턴 (Anti-Pattern) 인스턴스 생성 사례 불변 (Immutable Class) 객체의 재사용을 한다. 생성후 변경 불가능한 객체로서 대표적으로 String, Boolean, Integer, Float, Long 등등이 있다. 안티패턴 String str = new String(\"bikini\"); 권장 패턴 String str = \"bikini\"; 최신 JVM 상에서는 고정 문자열일때 컴파일러가 처음부터 바이트 코드를 StringBuilder 로 변경되어 인스턴스가 생성되지 않는다.하지만 가급적 문자열 연산이 많다면 StringBuilder 를 권장 오토 박싱 박싱된 Warpper 형 보다는 원시 기본 타입을 사용한다. private static long sum() { Long sum = 0L; for (long i = 0; i Stack Class 클래스의 메모리 누수 자기 메모리를 직접 관리하는 클래스라면 메모리 누수에 주의해야 한다. 캐시용도로 사용하는 객체는 WeackHashMap 을 사용 스택과 같은 객체는 사용후 null 로 참조해제를 시켜주도록 한다. public class Stack { private Object[] elements; ... public Object pop() { if (size == 0) { throw new EmptyStackException(); } Object result = elements[--size]; // 다 쓴 참조를 해제 해주도록 하자 elements[--size] = null; return result; } } Finalize Method finalize 메소드에 의한 Collection 지연과 OOME (Out of Memory Exception) 발생 가능성 때문에 사용을 지양한다. 특정 Class 에서 finalize 메소드가 정의되어 있는 경우 해당 Class Type 의 Object 는 Gabege Collection 발생시 즉각적으로 Collction 되지 않는다.이는 Finalization Queue 에 들어간 후 Finalizer 에 의해 정리되는데 참조가 해제된 객체에 대해서도 finalize 메소드에 의해 GC 실행이 보장되지 않는다. 대안 AutoCloseable 을 구현해주고 클래스에서 인스턴스를 다 사용하면 close 메소드를 호출해준다. 참고자료 http://www.yunsobi.com/blog/entry/finalize-메소드의-오버라이딩을-자제해야하는-이유 "},"book/03.-back-end/02.-server/":{"url":"book/03.-back-end/02.-server/","title":"02. Server","keywords":"","body":"02. Server "},"book/03.-back-end/02.-server/linux/":{"url":"book/03.-back-end/02.-server/linux/","title":"Linux","keywords":"","body":"Linux nslookup nslookup 명령어는 네임 서버 관련 조회를 할 수 있는 명령어이다.서버의 네트워크가 살아있는지 확인하는 용도로 사용한다. $ nslookup IP $ nslookup DOMAIN dig DIG (Domain Information Groper) 는 nslookup 과 동일한 기능이지만 더욱 상세한 출력이 가능합니다. 특정 도메인 확인 $ dig google.com 특정 네임서버를 통한 도메인 확인 $ dig @8.8.8.8 google.com 도메인 추적 확인 $ dig google.com +trace 참고자료 https://www.codns.com/b/B05-110 telnet 서버 네트워크가 살아있는지 확인하는 용도로 많이 사용 한다. $ telnet IP [PORT] $ telnet DOMAIN [PORT] service 리눅스 상에 서비스로 등록되어 있는 목록을 가져온다. # service --status-all 리눅스 상에 서비스를 기동 혹은 중지 시킨다. # service SERVICE_NAME start # service SERVICE_NAME restart # service SERVICE_NAME stop netstat 포트별 서비스 목록 # netstat -atlpvn # netstat -tnlp State LISTENING 서비스 대기중 ESTABLISHED 다른 컴퓨터와 연결된 상태 CLOSED 연결이 종료되어 있는 상태 TIME WAIT 연결은 종료 되었지만 당분간은 소켓은 열어놓은 상태 Options -a --all 모든 소켓을 보기 -c --continuous 현재의 실행 명령을 매 초마다 실행 -e --extend 확장 정보 추가 -g --groups 멀티캐스트에 대한 그룹별 정보를 보여줌 (IPv4/IPv6) -i --interface 인터페이스별 통계값 -n --numberic 도메인을 주소를 읽지 않고 숫자로 출력한다. 아래 3개의 명령어가 합쳐진 형태이다. --numberic-hosts : 호스트 부분을 IP 로 출력 --numberic-ports : 포트 부분을 숫자로 출력 --numberic-users : 유저 부분을 숫자로 출력 (UID) -o --timers 연결 대기 시간 표기 -p --program PID 와 사용중인 프로그램명을 표시 -r --route 라우팅 테이블 보기 -s --statistics 프로토콜 요약 정보 -t --tcp TCP 프로토콜 보기 -u --udp UDP 프로토콜 보기 -v 버전 보기 -w --row RAW 프로토콜 보기 -A 프로토콜별 보기 -M 마스커 레이딩 정보 표시 Crontab CLI 에디터 열기 $ crontab -e 작업 목록 $ crontab -l 작업 삭제 $ crontab -r 주기 설정 *　　　　　　*　　　　　　*　　　　　　*　　　　　　* 분(0-59)　　시간(0-23)　　일(1-31)　　월(1-12)　　　요일(0-7) 초단위로 실행할 경우 sleep 명령어 를 이용하면 된다. 참고자료 https://jdm.kr/blog/2 "},"book/03.-back-end/02.-server/linux/shell_script.html":{"url":"book/03.-back-end/02.-server/linux/shell_script.html","title":"Shell Script","keywords":"","body":"쉘 스크립트 (Shell Script) 참고자료 https://blog.gaerae.com/2015/01/bash-hello-world.htmlhttps://wiki.kldp.org/HOWTO/html/Adv-Bash-Scr-HOWTO/http://lsit81.tistory.com/entry/Bash-Shell-Script http://woowabros.github.io/tools/2017/08/17/ost_bash.html "},"book/03.-back-end/02.-server/nginx/":{"url":"book/03.-back-end/02.-server/nginx/","title":"NGINX","keywords":"","body":"NGINX 기존 Apache 랑 차이점 apache 요청마다 스레드 혹은 프로세스 생성 및 처리 nginx 요청마다 비동기 이벤트를 발생시켜 처리 proxy_pass /etc/nginx/sites-available/default 경로를 다음과 같이 수정한다. 이전 파일은 백업 한다. server { listen 80; server_name localhost; location / { proxy_pass http://localhost:8080; } } "},"book/03.-back-end/02.-server/nginx/cli/":{"url":"book/03.-back-end/02.-server/nginx/cli/","title":"CLI","keywords":"","body":"CLI Service Start $ sudo service nginx start $ sudo systemctl start nginx $ sudo /etc/init.d/nginx start Service Restart $ sudo service nginx restart $ sudo systemctl restart nginx $ sudo /etc/init.d/nginx restart Service Stop $ sudo service nginx stop $ sudo systemctl stop nginx $ sudo /etc/init.d/nginx stop Service Status $ sudo service nginx status $ sudo systemctl status nginx Service Status Reload 설정파일을 변경한 후 적용시 사용 $ sudo service nginx reload $ sudo systemctl reload nginx $ sudo nginx -s reload Configuration Check $ sudo nginx -t "},"book/03.-back-end/02.-server/nginx/cli/installation.html":{"url":"book/03.-back-end/02.-server/nginx/cli/installation.html","title":"Installation","keywords":"","body":"설치 (Installation) Docker Ubuntu 이미지를 받아서 설치 Docker 관련 내용과 중복될 수 있습니다. 설치 환경 Ubuntu 18.0.4 LTS 설치 준비 ubuntu 이미지 받기 $ docker pull ubuntu:latest Container 생성하기 $ docker run -i -t -d -p 9000:9000/tcp --name square-dev ubuntu /bin/bash apt-get 업데이트 $ apt-get update vim 설치 $ apt-get install vim Package 를 이용한 nginx 설치 nginx 다운로드 및 설치 설치 여부를 묻는게 귀찮으니 -y 옵션을 준다. $ apt-get install nginx -y 설치 확인 $ nginx -v nginx version: nginx/1.14.0 (Ubuntu) # version $ nginx -t nginx: the configuration file /etc/nginx/nginx.conf syntax is ok # config file 내용 (문법) 검사 nginx: configuration file /etc/nginx/nginx.conf test is successful # config file 테스트 결과 nginx 상태 $ service nginx status nginx 중지 $ service nginx stop nginx 기동 $ service nginx start "},"book/03.-back-end/03.-network/":{"url":"book/03.-back-end/03.-network/","title":"03. Network","keywords":"","body":"03. Network 다이제스트 (Digest) 과거에 DB 에 저장되어 있는 비밀번호와 사용자가 입력한 값을 직접 비교하는 프로세스가 일반적이였으나 보안이슈로 인하여 사용자의 비밀번호를 암호화하는 대표적인 방법으로 암호화 해시 함수 (Cryptographic Hash Function) 가 있다. 일반적으로 사용자가 입력한 비밀번호는 암호화 해시 함수를 거쳐 다이제스트 (Digest) 형태로 저장된다. 다이제스트 (Digest) 란 해시 함수라는 수학적인 연산을 통해 암호화된 메시지를 의미한다. 암호화 해시 함수의 특징은 단방향 이라서 역으로 추적이 거의 불가능하다. 대표적인 해시 함수는 MD5 SHA-1 SHA-256 등이 있다. 참고자료 http://www.itworld.co.kr/news/94202 TCP/UDP 포트 목록 기본적으로 권고되는 기본포트는 다음과 같으며 이는 IANA 의 권고안으로 구성된다.자주 사용되는 포트는 다음과 같다. PORT 설명 TCP UDP 20 FTP (파일 전송 프로토콜) - 데이터 포트 O 21 FTP - 제어포트 O 22 SSH (다른 FTP 프로그램의 의해서 SFTP의 기본 포트로 설정되는 경우가 있어 충돌이 난다) O 23 Telnet O 25 SMTP - 이메일 전송에 사용 O 80 HTTP - 웹 페이지 전송 O 443 HTTPS - SSL 위의 HTTP의 암호화 전송 O 990 SSL 위의 FTP의 암호화 전송 O OSI 7 Layer 계층 이름 장비 대표 프로토콜 설명 7계층 서비스 제공 DHCP, DNS, FTP, HTTP 응용 계층 (Application) 사용자와 상호작용 하는 응용 프로그램 이다.Chrome, FF, Safari 등과 같은 응용프로그램이 대표적이다. 6계층 표현 계층 (Presentation) 포맷 변환 JPEG, MPEG, SMB, AFP 데이터를 안전하게 보호하기 위하여 암호화 및 복호화를 하는 계층 5계층 세션 계층 (Session) 규칙 제어 SSH, TLS 세션을 만들고 설정하는 기능을 담당 4계층 전송 계층 (Transport) 게이트웨이 TCP, UDP, ARP 데이터의 전송을 조율하며 용량과 속도 및 목적지 등을 처리한다.대표적으로는 전송 제어 프로토콜(TCP) 이 인터넷 프로토콜 (IP) 위에 구축이 되는데 이를 TCP/IP 라고 한다. 3계층 네트워크 계층 (Network) 라우터 IP, ICMP, IGMP 라우팅 기능을 제공하는 계층IP가 여기서 작동한다. 2계층 데이터 링크 계층 (Data Link) 브릿지, 스위치 MAC, PPP 매체 접근 제어 (MAC) 계층으로 대부분의 스위치가 이 계층에서 동작된다. 1계층 물리 계층 (Physical) 허브, 리피터 Ethernet, RS-232C 시스템의 전기적, 물리적 표현을 나타내는 계층케이블의 연결 혹은 플러그 상태를 점검 가능하다. 참고자료 https://kimdongwook.tistory.com/entry/OSI-7계층http://www.ciokorea.com/news/36536http://blog.naver.com/PostView.nhn?blogId=hostinggodo&logNo=220708841767http://blog.naver.com/PostView.nhn?blogId=demonicws&logNo=40117378644 네트워크 스위치 (NetWork Switch) Switch 기능 L2 MAC Address 를 읽어 스위칭 작업을 한다. 라우팅이 불가능 하다. L3 IP 정보를 읽어 스위칭을 한다. L4 Port 번호 (TCP / UDP) 를 보고 스위칭을 한다. HTTP : 80 HTTPS : 444 FTP : 21, 22 L7 어플리케이션 경로를 보고 스위칭을 한다. (도메인 이후 경로) 각 스위치 장비는 자기보다 낮은 스위치의 기능까지 소화가 가능하다. (L7은 L4, L3, L2 영역까지 커버 가능) 가상 네트워크 (virtual Network) Virtual Box, VM Ware 같은 가상머신 프로그램을 이용하여 Host (로컬 PC) 내에 가상 네트워크를 구성할 수 있다. 구성 가능한 가상 네트워크의 종류는 다음과 같다. Host-Only 외부와 단절된 내부 네트워크를 구축하는 것 구성된 가상머신들끼리만 통신이 가능 NAT (Network Address Translation) Host PC 로부터 IP를 할당받아 가상머신 프로그램이 자체 DHCP 서버를 띄워 내부 네트워크 대역 할당 및 통신을 한다. Host PC 를 통해 외부 네트워크와 통신이 가능하다. Bridge 공유기로부터 IP 를 할당 받아 호스트와 동일한 네트워크 대역의 IP 를 갖게 된다. 공유기를 통해 외부 네트워크와 통신이 가능하다. 참고자료 http://developerin.tistory.com/18 DHCP (Dynamic Host Configuration Protocal) 서버 Host PC 에서 보유하고 있는 IP 를 유동적으로 관리하는 프로토콜이다.IP 자동 할당과 분배의 기능을 담당한다. 프록시 환경 (Proxy) 환경 프록시 서버 (Proxy Server) 란 중계서버 이다. 순방향 프록시 (Forward Proxy) 내부에서 외부로 접근 Proxy Server 에서 IN/OUT 바운드 패킷에 대한 보안정책 (Content Filtering) 을 적용할 수 있다. Proxy Server 내부에 Cache 를 유지하며 이미 한번 통신한 외부 서버의 이미지, 파일, 그 외정보들을 저장할 수 있다. Cache 용도로 사용한다. 역방향 프록시 (Reverse Proxy) 외부에서 내부로 접근 외부 사용자는 내부망에 대한 서버의 존재를 모르기 때문에 Reverse Proxy 서버에 들어오는 모든 접속은 Reverse Proxy 에 매핑되는 내부 서버의 정보를 알고 요청을 넘겨준다. Proxy 서버가 내부 서버의 정보를 알고 있으므로 로드 밸런싱을 통해 부하 여부에 따라 요청을 분배할 수 있다. 대부분 nginx 와 같은 Web Server 에서 설정한다. 참고자료 https://medium.com/sjk5766/nginx-reverse-proxy-사용하기-e11e18fcf843 "},"book/03.-back-end/03.-network/http/":{"url":"book/03.-back-end/03.-network/http/","title":"HTTP","keywords":"","body":"HTTP HTTP Header Request Header 클라이언트 브라우저에서 HTTP 프로토콜을 이용하여 요청 정보를 웹 서버로 전송할 때 HTTP 요청 헤더에 부가적인 정보를 담아 전송한다. Accept 클라이언트가 처리하는 미디어 타입 Accept-encoding 클라이언트가 해석할 수 있는 인코딩 방식 Accept-language 클라이언트가 지원하는 언어 Connection 클라이언트와 서버의 연결 방식 keep-alive : 클라이언트와 접속 유지 close : 클라이언트와 접속 중단 Host 호스트 이름 URI 와 PORT 번호 정보 User-agent 클라이언트 브라우저 정보 Response Header 서버가 HTTP 프로토콜을 이용하여 클라이언트의 요청에 대해 응답할 때 부가적인 정보를 응답 헤더에 담아 전송한다. Connection 클라이언트와 서버의 연결 방식 설정 keep-alive : 클라이언트와 접속 유지 close : 클라이언트와 접속 중단 Content-Length 요청한 파일의 데이터 길이 Content-Type 헤더 응답 문서의 mime 타입 Date 현재 일시를 GMT 형식으로 지정 Server 웹 서버 정보 CORS 관련으로 Access-Control-Allow-Origin: * 으로 설정되면 도메인 구분없이 XHR 호출이 가능해진다. Keep-alive 관련 디바이스 간의 커넥션을 유지하는 기법 으로 TCP 와 HTTP 가 전혀 다르다. TCP 는 OS가 제어 하고, HTTP 는 웹 서버가 제어 한다. HTTP 1.1 이상에서 지원되는 스팩으로 헤더에 설정 하면 된다. max 요청수 와 유효시간(timeout) 으로 구성된다. Timeout 종류 Connection Timeout Connection 을 구성하는데 소요되는 시간 Read Timeout Server 에서 데이터를 완전히 받을때 까지 걸리는 시간 MIME 서버가 클라이언트에게 전송되는 문서에 대한 유형을 지칭하는 타입 Syntax [파일의종류]/[파일타입] Type List text 텍스트 파일 text/plain, text/html, text/css, text/javascript multipart 이미지 파일 (비디오 제외) audio/midi, audio/mpeg, audio/webm, audio/ogg, audio/wav audio 오디오 파일 audio/midi, audio/mpeg, audio/webm, audio/ogg, audio/wav video 비디오 파일 video/webm, video/ogg application 모든 바이너리 타입 application/octet-stream, application/pkcs12, application/vnd.mspowerpoint, application/xhtml+xml, application/xml, application/pdf Cookie & Session & Cache HTTP 프로토콜의 상태 유지를 하기 위해 Server 가 Client 를 식별할 수 있도록 사용하는 방식 공통점 사용자에게 빠르게 서비스를 전달하기 위해 데이터를 저장해서 사용한다. 차이점 Cookie 클라이언트에 저장되는 키와 값이 들어있는 작은 데이터 파일 (하나당 4KB 이하) 이름, 값, 만료날짜 (쿠키의 저장시간), 경로정보 등이 포함되어 있으며 반드시 자료형은 String 으로 구성된다. 사용자가 임의로 쿠키 데이터를 저장, 수정, 삭제할 수 있다. 사용자가 브라우저 설정으로 쿠키의 사용유무를 설정할 수 있다. HTTP 전송시에 요청 헤더에 쿠키 값이 들어 있어 쿠키의 자료량 (데이터 사이즈) 이 큰 경우오버헤드로 인한 웹서버 에러가 발생 할 수 있다. Session 서버에서 사용하는 클라이언트 인증 정보이다. 서버는 접속 클라이언트 별로 세션을 생성해서 세션의 해당하는 쿠키 (Session ID) 를 클라이언트에게 생성하게 하고 이 클라이언트는 서버에 접속할 때마다 해당 쿠키의 값 (Session ID) 을 서버에 전송하여 세션을 유지하게 한다. 브라우저의 설정에 관계없이 동작하며, 세선 졍보로 Java 객체를 저장할 수 있다. Cache 정적 자원들을 안정적으로 서비스하기 위해 데이터를 미리 저장해두고 제공하는 방식 프록시 (Proxy) 서버에서 제공 참고자료 http://blog.kurien.co.kr/544http://brownbears.tistory.com/34http://asfirstalways.tistory.com/68 sendRedirect & forward 의 차이점 sendRedirect 새로운 요청을 작성하여 넘긴다.forward 에 비해 느리다. forward 요청 대상을 새로운 대상으로 전달한다.sendRedirect 에 비해 빠르다. Servlet Life Cycle Client 의 Request 에 따라 Servlet Engine 이 Servlet 을 로드한다. 로드된 Servlet 을 초기화 하기 위해 Servlet 의 init method 를 호출한다. Servlet 객체는 각 Request 에 따른 처리를 한다. 최종적으로는 distroy method 를 호출하여 Servlet 을 제거한다. HTTP METHOD GET URL로 파일 및 자원등을 가져올 수 있도록 요청 POST Request 로 전달된 데이터를 기반으로 서버에 요청 수행의 목적이 강함 DELETE 데이터 삭제의 요청 PUT Request 로 전달되는 데이터를 기반으로 서버에 요청 기준 데이터가 없을때는 생성, 있을때는 수정 PATCH 변경된 데이터만 전달하여 업데이트를 요청함 네트워크 핸드 쉐이크 ARC (Acknowledgement) : 송신된 메세지가 정상적으로 수신 되었음을 송신측으로 응답하는 것 SYN (Synchronize) : 연결시작 및 회선의 개선 용도로 사용 FIN (Finish) : 연결해제 및 회선 종결의 용도로 사용 연결 sequenceDiagram Client ->> Server: SYN Server -->> Client: ACK + SYN Client ->> Server: ACK 해제 sequenceDiagram Client ->> Server: FIN Server -->> Client: ACK Server -->> Client: FIN Client ->> Server: ACK "},"book/03.-back-end/03.-network/http/rest.html":{"url":"book/03.-back-end/03.-network/http/rest.html","title":"REST","keywords":"","body":"REST (Representational State Transfer) 자원을 이름으로 구분하여 해당 자원의 상태 정보를 주고 받는 모든것을 의미 한다. 구성요소 자원 모든 자원은 고유한 ID 가 존재하며 이 자원은 Server 에 존재한다. Client 는 URI 를 이용하여 자원을 지정하고 해당 자원의 상태정보에 대한 조작을 Server 에 요청 하게 된다. 행위 HTTP Method 이다. GET, POST, PUT, DELETE 와 같은 메서드를 제공하며 각각의 의미와 역활이 다르다. 표현 Client 가 자원의 상태정보 조작을 요청하면 Server 는 이에 대한 응답을 보내게 된다. 대부분은 JSON 및 XML 를 통해 데이터를 주고 받는것이 일반적이다. 특징 1. 유니폼 인터페이스 (Uniform Interface) 지정된 URI 인터페이스에서 자원 제공한다. 표준 HTTP 프로토콜을 따르는 플랫폼에서 사용 가능하다. 2. 무상태성 (Stateless) 상태를 갖지 않아 상태정보 (세션, 쿠키) 를 따로 저장하거나 관리할 필요가 없다. 단순히 API 서버는 들어오는 요청만 처리하여 구현이 단순해지고 서비스의 자유도가 높아진다. 3. 캐시 가능 (Cacheable) 표준 HTTP 프로토콜을 그대로 사용하므로 웹에서 사용하므로 해당 인프라를 그대로 활용할 수 있다. 캐시 사용으로 인한 응답이 빨라지고 REST Server 트랜젝션이 발생되지 않기 때문에 전체적인 응답시간 및 성능, 자원의 효울을 향상 시킬수 있다. 4. 자체 표현 구조 (Self-descriptiveness) REST API 의 메세지만 보고도 이를 쉽게 이해할 수 있는 자체 표현 구조로 되어 있다는 것 이다. 5. Clinet / Server 구조 자원이 있는 쪽은 Server, 자원을 요청하는 쪽은 Client 로 구성된다. Server : API 를 제공하고 비지니스 로직 처리 및 저장을 책임진다. Client : 사용자 인증이나 context (세션, 로그인 정보) 등을 직점 관리하고 책임진다. 서로간의 의존성이 줄어든다. 6. 계층형 시스템 (Layerd System) Client 는 Server 만 호출한다. API Server 는 순수 비지니스 로직을 수행하고 앞단에 보안, 로드밸런싱, 암호화, 인증 등의 추가하여 구조적 유연성을 가져간다. 프록시 혹은 게이트웨이와 같은 네트워크 기반의 중간 매체를 사용할 수 있다. REST API REST 기반의 서비스 API 로 구현한 것 이다. 설계 URI 는 정보의 자원을 표현해야 한다. 구분자 ( / ) 는 계층관계를 나타내는데 사용 URI 마지막 문자로 슬래시 ( / ) 를 사용하지 않는다. 하이픈 ( - ) 은 URI 가독성을 높이는데 사용 언더바 ( _ ) 는 사용하지 않는다. 경로 정보는 소문자로 한다. 파일 확장자는 포함하지 않는다. Method 는 의미와 역활이 맞아야 한다. Method 역활 GET 리소스를 요청한다. POST 리소스를 생성한다. PUT 리소스를 수정한다. DELETE 리소스를 삭제한다. 참고자료 https://meetup.toast.com/posts/92https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html "},"book/03.-back-end/03.-network/http/servlet.html":{"url":"book/03.-back-end/03.-network/http/servlet.html","title":"Servlet","keywords":"","body":"Servlet 등장배경 Java 를 사용하여 웹 페이지를 동적으로 생성하는 서버의 프로그램 (혹은 그 사양) 이며 서블릿 이라고 불린다. 자바 서블릿은 Java EE 사양의 일부분으로 주로 이 기능들을 이용하여 웹 시스템이 구현되고 있다. 과거에는 C C++ 을 이용해서 미들웨어 제품을 만들어서 판매를 하였는데 하드웨어 혹은 운영체제 종속성 때문에 어려움이 많았다.Java 플랫폼의 여러 장점들 (이식성, 독립성 등등) 을 활용하여 공통 API 로 제공하면 기존의 어려움을 충분히 개선해 나갈수 있었기 때문에 지금의 WAS (Web Application Server) 라고 불리우는 Java EE 어플리케이션 서버의 시작이 되었다. 그렇게 Java EE 는 많은 관심을 받아, 기업들은 WebLogic 이나 WebSphere, Apache Tomcat 등과 같은 WAS 제품을 앞다투어 출시하게 되었고 이후 등장하는 JSP 도 많은 사랑을 받는다. 역활 일반적인 웹 어플리케이션 환경의 프로그래밍에서 네트워크 통신을 미들웨어 중에서 대표적으로 Web Server 와 WAS (Web Application Server) 사용하여 구성을 한다. Web 서버는 보통 하드웨어 (물리적 서버) 와 소프트웨어로 구분되며 보통 이 둘을 통칭하여 Web 서버 라고 지칭한다.WAS 서버는 대부분은 애플리케이션을 수행해주는 미들웨어 (소프트웨어 엔진) 으로써 동적인 컨텐츠 수행 하는 역활을 담당한다. JSP (Java Server Page) 기존의 HTML에서 JAVA 코드의 사용이 가능한 JSP 와 같은 기술이 등장 하였고 이는 JAVA 기술을 대중화 시키는데도 한몫 하였다. javax.servlet.http.HttpServlet 클래스를 상속받은 Java 소스코드로 변환한 다음 컴파일 되어 실행하다. 하나의 JSP 페이지가 Java 클래스이기 때문에 모든 Java Library 의 사용이 가능하다. Servlet 의 장단점 장점 Thread 기반으로 하기 때문에 웹 어플리케이션 운영에 효율적이다. 병렬처리 Java 를 기반으로 대부분의 이점을 가져온다. Java 기분의 풍부한 API 사용이 가능하다. 이기종 OS 장비의 이식성이 우수하다. 컨텐츠와 비지니스 로직의 분리가 가능하다. 단점 서블릿은 완전한 자바 애플리케이션 이기 때문에 출력 가능한 HTML 문서를 프로그램적으로 서블릿 코드 안에 작성 해야 한다. 컨텐츠와 비지니스 로직의 분리가 어렵다. 서비스 이전에 컴파일 과정이 필요 로 한다. 위 같은 이유 때문에 JSP 와 Servlet 을 섞어 사용하여 장단점을 보완할 수 있다. Servlet Container 참고자료 http://blog.naver.com/PostView.nhn?blogId=00050004&logNo=70043657451 https://dololak.tistory.com/82 http://mangkyu.tistory.com/14 "},"book/03.-back-end/03.-network/http/http2.0.html":{"url":"book/03.-back-end/03.-network/http/http2.0.html","title":"HTTP 2.0","keywords":"","body":"HTTP 2.0 HTTP1 의 요청 방식 HTTP1 에서는 앞에서 날렷던 요청의 응답을 받아야만 다음 요청이 처리될 수 있다. sequenceDiagram Note over Client, Server : Establish Connection Client ->> + Server : Request Note right of Server: Blocked Server ->> - Client : Response Note over Client, Server : Close Connection Note over Client, Server : Establish Connection Client ->> + Server : Request Note right of Server: Blocked Server ->> - Client : Response Note over Client, Server : Close Connection 이러한 현상을 해결 하기위해 지속 커넥션 (Persistent Connection) 이라는 개념과 HTTP 파이프 라이닝 (Pipelining) 이라는 개념이 들어갔다.커넥션을 재사용할 수 있고, Request 를 미리 여러개 서버로 요청할 수 있게 되었다. 하지만 근본적으로 Request 보낸 순서대로 Response 를 받을수 있다는 점에서는 문제해결이 어려워 보인다. HOL (Head-of-Line Blocking) 의 문제점 만약 처음에 요청한 Request 에 문제가 있어 Response 가 늦어지면 2번째, 3번째에 요청한 Request 의 Response 도 늦어지는 문제점이 발생한다. gantt title Head-Of-Line Blocking dateFormat YYYY-MM-DD section HTTP Request 1 : crit, 2000-01-01 , 12d Request 2 : 6d Request 3 : 6d 도메인 샤딩 HOL 과 같은 문제들을 해결하기 위하여 리소스를 도메인 별로 분리해서 자원을 받는 방법도메인별로 리소스를 병렬적으로 동시에 받을수 있다. gantt title Domain Sharding dateFormat YYYY-MM-DD section Request HTML index.html : html, 2000-01-01 , 8d section A Domain style_1.css : css, after html, 6d style_2.css : after html, 6d style_3.css : after css, 6d style_4.css : after css, 6d section B Domain resource_1.js : js , after html, 6d resource_2.js : after html, 6d resource_3.js : after js, 6d resource_4.js : after js, 6d 하지만 하나의 도메인별 브라우저에서 받을수 있는 커넥션의 제한 이나 DNS Lookup 과정과 TCP Handshake 과정에서 소요되는 시간 때문에 오히려 부작용 발생 가능성이 있다. 브라우저당 도메인별 리소스 다운 제한은 보통 6 ~ 8 개정도 이며 iframe 은 제외이다. 그 외 방법들 HTTP 1.1 에서는 다음과 같은 방법을 통해서도 성능개선을 시도하였다. HTTP 요청 최소화 큰 이미지를 틍으로 요청후 CSS 로 잘게 잘라서 사용 BASE64 인코딩된 이미지를 요청해서 사용 소스 압축 HTML 의 gzip 압축 전송 JS, CSS 의 소스 압축 HTTP 2.0 의 다른점 바이너리로 인코딩된 데이터 전송 기존의 텍스트 기반의 데이터를 바이너리 포맷의 데이터로 사용하게 되어파싱이 더 빠르고 오류 발생 가능성이 적으며 하나의 플레인 데이터를 프레임 단위로 나눠서 관리 및 전송할 수 있다. HTTP 2.0 은 Frame 과 Stream 이라는 개념이 적용 되었다. HTTP 1.x 시절에는 요청 (Request) 과 응답 (Response) 으로 명확히 구분되었다. Frame HTTP2 통신에서 데이터를 주고 받을수 있는 가장 작은 단위의 데이터 헤더 프레임, 데이터 프레임으로 구성 Stream Server 와 Client 사이의 양방향으로 데이터를 주고 받는 한개 이상의 메세지 를 의미한다. 스트림 = 메세지 + 메세지 + 메세지 + 메세지 + 메세지 + 메세지 + ...메세지 = 프레임 + 프레임 + 프레임 + 프레임 + 프레임 + 프레임 + ... 우선순위 설정 상대적으로 중요한 리소스를 먼저 다운로드 받게 끔 전송 스트림의 우선순위 설정이 가능하다. Server Push 요청한 클라이언트에게 서버가 알아서 필요한 리소스를 찾아서 내려준다. gantt title Domain Sharding dateFormat YYYY-MM-DD section Request HTML index.html : html, 2000-01-01 , 8d section Server Push style_1.css : after html, 6d style_2.css : after html, 6d style_3.css : after html, 6d style_4.css : after html, 6d resource_1.js : after html, 6d resource_2.js : after html, 6d resource_3.js : after html, 6d resource_4.js : after html, 6d 하지만 브라우저가 캐싱된 데이터 나 필요없는 리소스 데이터 는 자원의 낭비를 초래할 수 있다. 헤더의 압축 HTTP2 의 Header 는 Header Table 로 관리 되어 이전 요청에서 중복으로 선언된 헤더는 인덱스 값만 전송하여 데이터를 최소화 한다. 적용 방법 TSL / SSH 인증서 필요 웹서버의 세팅 고려사항 일부 환경에 대해서는 효율이 떨어져 적용 환경에 따른 고려가 필요하다. HTTP 2.0 효율이 낮은 경우 HTTP 1.1 보다 성능적으로는 우수하지만 적용하였을때의 아래와 같은 상황일 경우 성능적 이점이 차이가 없는 경우도 있다. HTTP 만 사용하는 경우 SSL 핸드셰이크 시간이 추가적으로 필요하여 추가 시간 소요 도메인이 많은 경우 도메인별로 동작하므로 도메인별로 커넥션이 필요로 하다 이에 따른 시간적 효율이 떨어진다. HTTP 가 병목 현상이 없는 경우 RTT (Round-Trip Dealy Time : 메세지를 원격에 보내고 그것이 돌아오는 응답시간 - 레이턴시) 가 작은 경우 레이턴시가 큰 경우에만 더 큰 효율을 얻을수 있기 때문에 RTT 가 매우 작은 경우에는 이점이 없다. 페이지 내의 리소스가 적은 경우 6개 이하의 리소스를 가진다면 커넥션 재사용의 가치가 떨어진다. 일부 클라이언트 브라우저에 의해서 지원 가능성이 상이하여 확인이 필요하다. 지원 가능 브라우저 IE11 (Win10 ver) IE Edge Chrome IOS Chrome Firefox Opera 기타 브라우저 참고자료 https://d2.naver.com/helloworld/140351http://americanopeople.tistory.com/115https://www.popit.kr/나만-모르고-있던-http2/https://kinsta.com/learn/what-is-http2/ "},"book/03.-back-end/04.-rdbms/":{"url":"book/03.-back-end/04.-rdbms/","title":"04. Database","keywords":"","body":"04. Database SQL Injection 코드 인젝션의 한 기법으로 클라이언트의 입력값을 조작하여 서버의 데이터베이스를 공격하는 방식을 말한다. 방어 방법 권한으로 제한하는 방법 Query String 을 실행을 권한에 따라 제한할 수 있도록 한다. 입력값 검증 정규식 혹은 유효값의 vaildation 확인을 한다. Prepared Statement (저장 프로시저) 사용 현존하는 가장 좋은 방법으로 사용전에 일부 컴파일 되어 실행된다.Query 에 미리 형식을 지정하는 것으로 지정된 형식의 Query 형식이 아니면 실행되지 않는다. try{ String uId = \"admin\"; String query = \"SELECT * FROM user_info WHERE uId= ?\" stmt = conn.prepareStatement(query); stmt.setString(1, uId); ResultSet rs = stmt.executeQuery(); while(rs.netxt()) { /* statement */ } } catch () { /* statement */ } finally { /* statement */ } 샤딩 (Sharding) 같은 테이블 스키마를 가진 데이터를 다수의 데이터 베이스에 분산하여 저장하는 방법을 의미 참고자료 https://nesoy.github.io/articles/2018-05/Database-Shard "},"book/03.-back-end/04.-rdbms/01.redis.html":{"url":"book/03.-back-end/04.-rdbms/01.redis.html","title":"01.Redis","keywords":"","body":"01.Redis 인메모리 기반의 데이터 베이스 설치하기 1. 의존 라이브러리 설치 $ sudo apt-get update $ sudo apt-get install build-essential tcl 필수 패키지 build-essential C, C++ 컴파일 환경을 구성 가능하게 한다. gcc, make 를 한번에 설치한다. tcl Tool Command Language 설치한 응용 프로그램을 확장하는 것을 돕는 프로그램 언어 2. 소스 다운로드 및 압축 해제 $ mkdir /tmp/src $ cd /tmp/src $ curl -O http://download.redis.io/redis-stable.tar.gz $ tar xvfz redis-stable.tar.gz $ cd redsi-stable 3. 컴파일 # 빌드 $ make # 생략 가능 $ make test # 명령어 설치 $ make install 4. 실행 systemctl 명령어 $ sudo systemctl start redis $ sudo systemctl status redis systemctl 안될 때 # 서버기동 $ redis-server # Redis 접속 (새 터미널로) $ redis-cli 클라이언트 접속 툴 https://github.com/luin/medis?fbclid=IwAR3o5CCwylxYkSQGbxoqkI35pqGl41fx9v6nBJLeKbnXoU7CvzSW9j_WvKU 클라이언트 접속 툴 사용시 외부에서 접속 불가 할 수 있으니 protected-mode 를 해제하고 사용하도록 한다. $ redis-cli 127.0.0.1:6379> config set protected-mode no OK Issue 설치 이후에 redis 서버가 기동이 불가함 해당 소스파일 경로로 redis-server.sh 로 기동 이후 redis-cli 사용 가능함 추후 서비스로 등록하여 데몬으로 기동 가능하게 설정 해야 함 참고자료 https://hanee24.github.io/2018/01/05/how-to-install-redis-on-ubuntu-16-04/https://zetawiki.com/wiki/우분투16_redis_설치 http://hyunalee.tistory.com/17 "},"book/03.-back-end/05.-framework/":{"url":"book/03.-back-end/05.-framework/","title":"05. Framework","keywords":"","body":"05. Framework Framework vs Library 가장 크게는 제어의 흐름이 다르며Framework 는 사용자의 코드가 프레임워크에 사용되는 것이고Library 는 사용자에 코드에 의해 소비되는 것이다. Framework 는 IoC 개념이 적용되어야 하며 이는 특정의 프로세스를 프레임워크가 처리 가능하도록 제어를 넘김으로써 클라이언트 코드가 라이브러리의 메소드를 호출해서 사용하는 것 을 의미합니다. "},"book/03.-back-end/05.-framework/spring/":{"url":"book/03.-back-end/05.-framework/spring/","title":"Spring","keywords":"","body":"Spring 스프링 프레임워크의 전반적인 이야기를 다루도록 한다. 참고자료 https://spring.io/projects 아티팩트 (Artifact) 아티팩트는 소프트웨어 개발 프로젝트를 진행하면서 생성하는 다양한 산출물 을 의미한다. 통상적으로는 라이브러리와 동일한 의미로 해석 되며 .jar, .war, .ear 등의 확장자를 갖게된다. 아티팩트 저장소 (Artifact Repository) 아티팩트 저장소는 아티팩트와 메타데이터를 저장하고 관리하는 저장소를 의미한다. 저장소는 계층구조로 접근 가능하며 이 계층적 구조를 GAV (Group, Artifact, Version) 구조라고 하며 메이븐 (Maven) 에서 의존성을 찾을 때 참고하는 구조이기도 한다. 넥서스 (Nexus) 가 이 저장소에 사용되는 대표적인 제품이다. 참고자료 https://www.lesstif.com/pages/viewpage.action?pageId=18219542 @Autowired vs @Qualifier 의 차이 @Autowired 는 자동 주입 기능으로 스프링이 알아서 의존 객체를 찾아서 명시해준다.즉 자동 주입기능을 사용하면 별도의 설정이 없어도 의존 Bean 객체를 찾아서 주입해준다. 하지만 같은 타입의 빈이 두개 이상 존재할 경우에는 컨테이너 초기화 하는 과정에서 에러가 발생하기 때문에 주입할 객체를 특정 지어줘야 한다.이때 @Qualifier 를 사용해 줘야 한다. "},"book/03.-back-end/05.-framework/spring/fundamental/":{"url":"book/03.-back-end/05.-framework/spring/fundamental/","title":"Fundamental","keywords":"","body":"Fundamental "},"book/03.-back-end/05.-framework/spring/fundamental/aop.html":{"url":"book/03.-back-end/05.-framework/spring/fundamental/aop.html","title":"AOP","keywords":"","body":"AOP (Aspect Oriented Programming : 관점 지향 프로그래밍) 어플리케이션 전체에 사용되는 기능을 재사용 하도록 지원 하도록 도와주는 것 관심의 분리 (Seperation of Concerns) 를 통하여 핵심 관심 사항 (입금, 출금, 이체) 에 집중 하는것이다. 기능을 핵식 비지니스 로직과 공통 모듈로 분리하고, 핵심 로직에 영향을 미치지 않고 사이사이에 공통 모듈을 효과적으로 잘 끼워 넣도록 코드밖에서 설정된다는 것이 핵심이다. 프로그램 파악이 힘들기 때문에 AOP 의 사용이 많을 경우에는 유지보수의 관리적인 측면이 어려움이 많다. 장점 중복되는 코드 제거 효율적인 유지보수 높은 생산성 재활용성 극대화 유연한 변화 수용 사용 다음은 사용 방법을 알아보자 (Spring Boot 기준) 주요개념 Aspect 여러 객체에 공통으로 적용되는 횡단 관심 모듈을 정의 Joinpoint Advice 를 적용 가능한 지점으로 Method 를 호출 필드 값 변경이 해당 Spring 에서는 Method 호출만 지원 Interceptor Interceptor Chain 방식의 AOP 툴에서 사용되는 용어로서 주로 한개의 호출 Method 를 가지는 Advice Advice 언제, 어떤 공통 관심 기능을 핵심 관심 모듈에 적용할 지를 정의 Weaving Advice 를 핵심 관심 모듈에 적용하는 것을 정의 Pointcut 횡단 관심 모듈이 적용될 메소드를 선정하는 방법으로 스프링에서는 정규 표현식이나 Aspect J 문법을 통해 정의 Advice 의 종류 Before 대상 객체의 Method 호출 전 실행 After Returning 대상 객체가 Exception 없이 정상적으로 실행된 후 실행 After Throwing 대상 객체의 Exception 과 상관없이 실행 finally 의 기능과 비슷함 Around 대상 객체의 메서드 호출 전, 후 또는 Exception 발생 시점에 실행 Example package com.square.common.advice; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Before; import org.aspectj.lang.annotation.After; import org.aspectj.lang.annotation.AfterReturning; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Pointcut; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; @Aspect @Component @Order(0) public class LoggerAdvice { private static final Logger logger = LoggerFactory.getLogger(LoggerAdvice.class); @Before(\"execution(* com.square..controller.*Controller.*(..))\") public void logServiceAccessBefore(JoinPoint joinPoint) throws Throwable{ logger.info(\"Logger Advice Before\"); } @After(\"execution(* com.square..controller.*Controller.*(..))\") public void logServiceAccessAfter(JoinPoint joinPoint) throws Throwable{ logger.info(\"Logger Advice After\"); } @AfterReturning(pointcut=\"execution(* com.square..controller.*Controller.*(..))\", returning=\"str\") public void logServiceAccessAfterReturning(JoinPoint joinPoint, Object str) throws Throwable{ logger.info(\"Returning is \" + str); logger.info(\"Logger Advice AfterReturning\"); } @Pointcut(\"execution(* com.square..controller.*Controller.*(..))\") public void logServiceAccessPointcut() {} @Before(\"logServiceAccessPointcut()\") public void logServiceAccessPointcutBefore(JoinPoint joinPoint) { logger.info(\"[Pointcut] Logger Advice Before\"); } @After(\"logServiceAccessPointcut()\") public void logServiceAccessPointcutAfter(JoinPoint joinPoint) { logger.info(\"[Pointcut] Logger Advice After\"); } @AfterReturning(value=\"logServiceAccessPointcut()\", returning=\"str\") public void logServiceAccessPointcutAfterReturning(JoinPoint joinPoint, Object str) { logger.info(\"[Pointcut] Returning is \" + str); logger.info(\"[Pointcut] Logger Advice AfterReturning\"); } @Around(\"execution(* com.square..controller.*Controller.*(..))\") public Object logServiceAccessPointcutAround(ProceedingJoinPoint processedJoinPoint) throws Throwable { logger.info(\"[Pointcut] Logger Advice Around Before\"); Object obj = processedJoinPoint.proceed(); logger.info(\"[Pointcut] Logger Advice Around After\"); return obj; } } AOP 적용 대상 페이지를 호출하면 다음과 같이 로그가 남는다. [Pointcut] Logger Advice Around Before Logger Advice Before [Pointcut] Logger Advice Before [Pointcut] Logger Advice Around After Logger Advice After ## # 컨트롤러 로직 처리 ## [Pointcut] Logger Advice After Returning is index Logger Advice AfterReturning [Pointcut] Returning is index [Pointcut] Logger Advice AfterReturning 참고자료 https://heowc.github.io/2018/02/07/spring-boot-aop/http://jyh1536.tistory.com/66http://addio3305.tistory.com/86https://jojoldu.tistory.com/27 "},"book/03.-back-end/05.-framework/spring/fundamental/ioc.html":{"url":"book/03.-back-end/05.-framework/spring/fundamental/ioc.html","title":"IoC","keywords":"","body":"IoC (Inversion of Control : 제어의 역전) 프로그램의 제어의 흐름 구조가 바뀌는 것 이다. 일반적인 객체의 흐름은 다음과 같다. 객체 생성 의존성 객체 생성 (클래스 내부) 의존성 객체 메소드 호출 하지만 스프링 내부에서는 다음과 같은 순서로 생성 및 실행된다. 객체 생성 의존성 객체 주입 (스프링에게 위임하여 만들어놓은 객체) 의존성 객체 메소드 호출 스프링이 모든 의존성 객체를 스프링이 실행될때 다 만들어 주고 필요한 곳에 주입시켜줌으로써Bean 들은 싱글턴 패턴의 특징 을 가진다. 제어의 흐름을 사용자가 컨트롤 하는것이 아닌 스프링에게 맏겨 작업을 처리(스프링이 처리) 하게 된다. (일반적인 Java 소스들은 스스로 제어 및 소비함) 사용자는 자신이 만든 객체가 어디에 사용되는지 알 수 없고 제어 권한을 위임받는 특별한 객체에 의해서 만들어지고 사용된다. (자신들이 만든 Java 소스가 프레임워크에 의해 소비됨) 이는 다음 두가지의 구현 방법으로는 다음과 같다. DL (Dependency Lookup : 의존성 검색) 저장소에 저장되어 있는 빈 (Bean) 에 접근하기 위해 개발자들이 컨테이너에서 제공하는 API 를 이용하여 사용하고자 빈을 Lookup 하는 것 DI (Dependency Injection : 의존성 주입) 각 계층 사이와 각 클래스 사이의 필요로 하는 의존 관계를 컨테이너가 자동으로 연결해 주는것 DL 을 사용시 컨테이너의 종속성이 증가하여, 이를 줄이기 위해서 DI 를 사용 public class Parent { private Child child; public void setChild(Child child) { this.child = child; } } 스프링에서는 객체의 생성과 소멸에 관련된 작업을 자동으로 수행해 주는데 객체가 생성되는곳을 Bean Container 라고 한다. 스프링에서는 객체를 Bean 이라고 부르며, 프로젝트가 실행될 때 사용자가 Bean 으로 관리하는 객체들을 자동으로 생성해 준다. 스프링에서 실행할 때 생성했던 Bean 을 주입시켜주는 과정을 DI 라고 한다. 참고자료 http://isstory83.tistory.com/m/91https://private.tistory.com/39 "},"book/03.-back-end/05.-framework/spring/fundamental/bean.html":{"url":"book/03.-back-end/05.-framework/spring/fundamental/bean.html","title":"Bean","keywords":"","body":"Bean 스프링 (정확히는 스프링 컨테이너) 에서 생성 및 및 관계 설정, 사용등을 제어해주는 객체 Bean Factory 스프링이 IoC 를 담당하는 핵심 컨테이너 빈을 등록/생성/조회/반환/관리 하는 기능으로 bean factory 와 같지만 여기에 spring 의 각종 부가서비스를 추가로 제공해야 한다. Application Context bean factory 를 확장한 IoC 컨테이너 Container (IoC Container) 객체를 관리하는 컨테이너로써 컨테이너에 객체를 담아두고 필요할 때에 컨테이너에서 객체를 가져와 사용할 수 있도록 한다. IoC 방식으로 Bean 을 관리한다는 의미에서 Bean Factory 나 Application Context 를 가르킨다. POJO (Plain Old Java Object) Sun 의 Java Bean 이나 EJB 의 Bean 을 뜻하는 것이 아닌 순수하게 getter, setter 메서드로만 이루어진 Value Object 성의 Bean 을 의미한다.예를 들면 다음과 같은 코드이다. public class SimpleBean { private String name; private String age; public void setName(String name) { this.name = name; } public String getName() { return this.name; } public void setAge(String age) { this.age = age; } public String getAge() { return this.age; } } 스프링에서 POJO 가 중요한 특징인 이유는 다음과 같은 특성을 가지기 때문이다. 클래스위 상속을 강제하지 않는다. 인터페이스의 구현을 강제하지 않는다. 어노테이션의 사용을 강제하지 않는다. 때문에 사용자는 라이브러리나 컨테이너의 별도 기술에 종속적이지 않는 상태로 가장 일반적인 코드로 작성할 수 있다는 것이다. 참고자료 http://m.blog.naver.com/weekamp/186678831https://joonyon.tistory.com/18 Spring Bean Life Cycle graph TD; A[\"빈 설정 파일 정보 초기화\"] --> B[\"POJO 빈 초기화 상태\"] B --> C[\"POJO 빈 준비 상태\"] C --> D[\"POJO 빈 소멸 상태\"] 참고자료 http://javaslave.tistory.com/48https://gmlwjd9405.github.io/2018/11/10/spring-beans.htmlhttps://unabated.tistory.com/entry/Spring-Bean-초기화-및-생명주기 POJO (Plain Old Java Object) 초기화 과정 Spring Framework 는 먼저 Bean 설정파일의 POJO 빈을 Instance 화 하지 않은 상태로 Bean 설정 파일의 정보를 초기화 한다. 빈 설정 파일의 정보를 초기화 하면서 XML DTD 에 대하여 유효한지 체크한다. Bean Instance 를 생성하면서 의존 관계에 있는 Bean 이 존재하는지 여부를 체크한다. 의존 관계가 없는 Bean 인 경우 초기화가 실패 한다. 의존 관계가 있는 빈의 체크가 완료되면 setter Method 를 호출하거나 생성자의 인자로 실질적인 값을 추가하거나 다른 Bean 에 대한 Reference 로 전달한다. Application Context 를 이용하여 초기화를 실행한다. 생성한 Bean 이 BeanNameAware Instance 이면 setBeanName() Method 를 호출한다. 생성한 Bean 이 BeanFactoryAware Instance 이면 setBeanFactory() Method 를 호출한다. 생성한 Bean 이 ApplicationContextAware Instance 이면 setApplicationContext() Method 를 호출한다. 생성한 Bean 이 InitalizingBean 인스턴스이면 afterProperties() Method 를 호출한다. 생성한 Bean 의 설정파일에 init-method 가 설정되어 있다면 init-method 에 해당하는 Method 를 호출한다. 종료 Method 를 호출하는 과정 생성한 Bean 이 DisposableBean Instance 이면 distory Method 를 호출한다. 생성한 Bean 설정파일에 distory-method 가 설정되어 있으면 destory Method 에 해당하는 메소드를 호출한다. Bean Life Cycle 을 커스터마이징 하여 제어 할 수 있다. Bean 로드 순서를 결정짓는 방법 Bean 내부적으로도 생성 순서에 따라 에러가 나올수 있기 때문에 해당 상황에서는 빈 생성 순서를 정해주는 것이 낫다 @DependsOn 의존성 고리를 스프링에게 알려준다. @PostConstruct 해당 컴포넌트가 완전히 생성된 후 한번에 실행해야 할 일을 코딩한 메소드에 붙이는 것이다. @Order 주입 순서를 정해 줌 참고자료 https://jeong-pro.tistory.com/167 @Bean vs @Component 차이 @Bean 외부 라이브러리들의 사용을 Bean 으로 등록하고 싶은 경우 @Component 사용자가 직접 컨트롤이 가능한 Class 인 경우 사용자가 생성한 클래스에 @Bean 선언은 불가능하다 이는 각자 선언할 수 있는 타입이 정해져 있어 해당 용도를 벗어나면 컴파일 에러를 발생시킨다. 참고자료 https://effectivesquid.tistory.com/entry/Bean-과-Component의-차이 Bean Scope eGov 및 Spring Reference (4.2.5) 에서 발췌한 Bean Scope 의 종류이다. Scope Description eGov Spring Reference Global Session 하나의 Bean 정의에 대해서 하나의 global HTTP Session의 생명주기 안에 단 하나의 객체만 존재한다. 일반적으로 portlet context 안에서 유효하다. Web-aware Spring ApplicationContext 안에서만 유효하다. O O Prototype 하나의 Bean 정의에 대해서 다수의 객체가 존재할 수 있다. O O Request 하나의 Bean 정의에 대해서 하나의 HTTP request의 생명주기 안에 단 하나의 객체만 존재한다 즉, 각각의 HTTP request는 자신만의 객체를 가진다. Web-aware Spring ApplicationContext 안에서만 유효하다. O O session 하나의 Bean 정의에 대해서 하나의 HTTP Session의 생명주기 안에 단 하나의 객체만 존재한다. Web-aware Spring ApplicationContext 안에서만 유효하다. O O singleton 하나의 Bean 정의에 대해서 Spring IoC Container 내에 단 하나의 객체만 존재한다. O O application 서블릿 컨텍스트의 라이프사이클에 정의된다. Spring Application Context 내에서만 유효하다. X O 참고자료 https://www.slipp.net/wiki/pages/viewpage.action?pageId=25528177 "},"book/03.-back-end/05.-framework/spring/fundamental/dispatcherServlet.html":{"url":"book/03.-back-end/05.-framework/spring/fundamental/dispatcherServlet.html","title":"Dispatcher Servlet","keywords":"","body":"Dispatcher Servlet MVC (Model, View, Controller) 구조로 구성되어 있는 Spring Framework 내에 원활한 처리를 위한 과정이다. 동작 구성 클라이언트가 요청한 정보를 최초에 DispatcherServlet 에서 가로챈다. web.xml 에 등록되어 있는 DispatcherServlet 의 이 '/' 로 등록 되어 모든 URL 패턴에 동작 되기 때문이다. 특정 URL 에만 적용이 필요하면 내용의 범위만 바꿔주면 된다. 가로챈 정보를 HandlerMapping 에게 보내 해당 요청을 처리할 수 있는 Controller 를 찾아낸다. 요청을 처리할 Controller 를 찾아 냈으면 해당 Controller 에게 해당 요청 정보를 보내준다. Controller 는 해당 요청 내용을 처리 후 요청을 응답 받을 View 의 이름을 리턴하게 된다. 실제로 응답전에 View Resolver 가 미리 응답할 내용을 분석하여 해당 View 이름을 검색 한다. 해당 View 가 있다면 처리 결과를 View 에 보낸후 이 결과를 다시 DispatcherServlet 에 보낸다. DispatcherServlet 은 받은 정보를 최종적으로 클라이언트에 전송하게 된다. sequenceDiagram Client ->> + Dispatcher Servlet : URL 로 접근하여 정보를 요청 Dispatcher Servlet ->> + Handler Mapping : 해당 요청을 매핑한 컨틀롤러가 있는지 검색 Handler Mapping ->> + Controller : 처리요청 Controller ->> - Dispatcher Servlet : 클라이언트의 요청을 처리후, 결과의 View 이름을 리턴 Dispatcher Servlet ->> + View Resolver : 컨트롤러에서 보내온 View 이름으로 검색 View Resolver ->> + View : 처리결과를 View 에 전달 View ->> - Dispatcher Servlet : 처리결과가 포함된 View 를 Dispatcher Servlet 에 전달 Dispatcher Servlet ->> - Client : 최종결과 출력 참고자료 http://egloos.zum.com/springmvc/v/504151 "},"book/03.-back-end/05.-framework/spring/fundamental/gradle.html":{"url":"book/03.-back-end/05.-framework/spring/fundamental/gradle.html","title":"Gradle","keywords":"","body":"Gradle Gradle 설치 Mac # brew gradle Ubuntu # 저장소 추가 $ add-apt-repository ppa:cwchien/gradle # apt-get 업데이트 $ apt-get update # Gradle 설치 $ apt-get install gradle 참고자료 https://zetawiki.com/wiki/우분투_Gradle_최신버전_설치 Gradle 빌드 # gradle build Gradle Build 시에 실행가능한 jar 만들기 manifest 파일을 생성하여 등록 해야 한다. 참고자료 http://theeye.pe.kr/archives/2075 "},"book/03.-back-end/05.-framework/spring/boot/":{"url":"book/03.-back-end/05.-framework/spring/boot/","title":"Boot","keywords":"","body":"Spring Boot Spring Boot 기동 Linux Deploy Shell Script 리눅스 환경에서 쉽게 관리를 위해 Shell Script 형태로 만들어 두어 관리한다. start.sh 앱을 시작하고 해당 PID 를 파일에 저장한다. #!/bin/bash java -jar myapp.jar & echo $! > ./pid.file & stop.sh 저장된 PID 를 사용하여 앱을 중지 한다. #!/bin/bash kill $(cat ./pid.file) 참고자료 https://code.i-harness.com/ko/q/195154c Gradle 로 Spring Boot 기동 # gradle bootRun 빌드 파일 기동 기본 기동 $ java -jar ./sq_wf-0.0.1-SNAPSHOT.jar 포트 8888 변경하여 기동 $ java -jar -Dserver.port=8888 ./sq_wf-0.0.1-SNAPSHOT.jar spring.profiles.active 값 지정하여 기동 $ java -jar -Dserver.port=8888 -Dspring.profiles.active=release ./sq_wf-0.0.1-SNAPSHOT.jar 히카리 (Hikari CP) Spring Boot 2.0 부터 지원 하는 JDBC Connection Pool 이다. 참고자료 http://jeong-pro.tistory.com/162http://netframework.tistory.com/entry/HikariCP-소개 "},"book/03.-back-end/05.-framework/spring/boot/thymeleaf.html":{"url":"book/03.-back-end/05.-framework/spring/boot/thymeleaf.html","title":"Thymeleaf","keywords":"","body":"타임 리프 (Thymeleaf) 스프링 부터에서 사용 가능한 뷰 (View) 들은 아래와 같은 종류가 있다. FreeMarker Groovy Thymeleaf Velocity JSP 이들 중에 Thymeleaf 에 관해서 알아보도록 하겠다. 참고자료 http://millky.com/@origoni/post/1144https://github.com/ihoneymon/spring-boot-orm-learn/blob/master/THYMELEAF_TEMPLATE_ENGINE.md "},"book/03.-back-end/05.-framework/spring/batch/":{"url":"book/03.-back-end/05.-framework/spring/batch/","title":"Batch","keywords":"","body":"Spring Batch 일괄 처리가 가능한 어플리케이션 프레임워크 이며 다음조건을 만족한다. 대용량 데이터 대량의 데이터를 가져오거나 혹은 전달 및 계산등의 처리가 가능 자동화 사용자의 개입 없이 실행가능 견고함 잘못된 데이터를 충돌 및 중단 없이 처리 가능 신뢰성 로깅 및 알림의 지원을 통하여 이슈 트래킹 가능 성능 지정된 시간안에 처리완료 다른 어플리케이션을 방해하지 않도록 수행 대부분 Rabbit MQ 와 연동하여 사용한다. 참고자료 https://jojoldu.tistory.com/324?category=635883 "},"book/03.-back-end/05.-framework/spring/batch/rabbitmq.html":{"url":"book/03.-back-end/05.-framework/spring/batch/rabbitmq.html","title":"Rabbit MQ","keywords":"","body":"Rabbit MQ AMQP 프로토콜을 구현한 메시지 브로커이다. AMQP (Advenced Message Queuing Protocal : 어드벤스드 메시지 큐잉 프로토콜) 메시지 지향 미들웨어 를 위한 개방형 표준 응용 계층 프로토콜이며 다음 기능들을 지향한다. 메시지 지향 큐잉 라우팅 (P2P 및 발행-구독) 신뢰성 보안 위 사항들을 지향하는 데이터 형식을 따르는 메시지를 만들고 이를 해석 가능한 도구라면 구현 언어에 관계없이 다른 호환 도구와 상호운용이 가능하다. 작성중 ... 참고자료 http://itstory.tk/entry/Message-Queue-RabbitMQ란https://brunch.co.kr/@springboot/51 http://abh0518.net/tok/?p=384 "},"book/03.-back-end/05.-framework/spring/security.html":{"url":"book/03.-back-end/05.-framework/spring/security.html","title":"Security","keywords":"","body":"Spring Security Java EE 기반의 Enterprise Software Application 을 위한 포괄적인 보안 서비스이다. Spring Security 는 보안을 구성하는 다음 두가지 영역이 있다. graph LR A[\"Authentication (인증)\"] --> B[\"Authorization (권한)\"] Authentication (인증) 사용자가 애플리케이션 작업을 수행할 수 있는 Authorization (권한) 을 얻는 과정 Authorization (권한) 애플리케이션의 작업을 수행할 수 있도록 허락되어 있는 결정 일반적으로 로그인 과 같은 과정들은 HTTP 기본인증을 통하여 진행되며 이는 Form 기반 로그인 이 된다. "},"book/03.-back-end/05.-framework/hibernate.html":{"url":"book/03.-back-end/05.-framework/hibernate.html","title":"Hibernate","summary":"Boss 에서 개발한 ORM (Object Relational Mapping) 프레임워크 이다.","keywords":"","body":"Hibernate ORM (Object Relational Mapping) RDBMS 테이블을 객체지향적으로 사용하기 위한 기술이다.RDBMS 는 객체지향적 접근이 쉽지 않기 때문에 ORM 을 사용하여 객체와 RDBMS 사이를 객체 지향적으로 다루기 위한 기술이다. "},"book/03.-back-end/06.-devops/":{"url":"book/03.-back-end/06.-devops/","title":"06. DevOps","keywords":"","body":"06. DevOps 프로비저닝 (Provisioning) 특정한 무언가를 위해서 최적의 리소스를 찾아놓고 요청에 맞게 공급하는 행위를 Provisioning 이라고 한다. 프로비저닝의 종류 서버 자원 관점 CPU, Memory 등의 자원을 할당 또는 적절하게 배치 OS 자원 관점 OS 를 서버에 설치하고, 구성 작업을 해서 OS 가 기동되도록 준비해놓는것 소프트웨어 자원 관점 소프트웨어 (was, dbms, application 등등) 을 시스템에 설치 및 배포하고 필요한 구성 세팅 작업을 해서 바로 실행 가능한 상태로 유지 스토리지 자원 관점 낭비되거나 사용되지 않는 스토리지를 식별하고 공통 풀에 가져다 놓는다. 스토리지의 요구가 접수되면 공통 풀에서 꺼내 사용할 수 있음 스토리지의 효율을 높일 수 있는 인프라 구축 가능 계정 프로비저닝 사용자 각각의 계정을 생성하거나 접근권한을 변경해주는 일련의 과정을 일컫음 참고자료 http://sugerent.tistory.com/284 "},"book/03.-back-end/06.-devops/docker/":{"url":"book/03.-back-end/06.-devops/docker/","title":"Docker","keywords":"","body":"Docker Docker 란? 호스트 OS 위에 게스트 OS 전체를 가상화 시키는 기존 방식과는 달리CPU 의 가상화 기술 (HVM) 을 이용한 KVM (Kernel-based Virtual Machine) 과 반가상화 (Paravirtualization) 방식의 Xen 방식으로 구성된다.Docker 는 프로세스를 격리 시켜 하나의 독립된 OS 처럼 가상화 시키는 방법으로 사용된다. Docker 에서는 이미지를 가지고 컨테이너로 구성하여 사용한다. -이미지는 변하지 않으며 (Immutable) 특성을 가진다.컨테이너는 이미지를 실행한 상태로 추가되거나 변경되는 값은 컨테이너에 저장된다._ 참고자료 초보를 위한 도커 안내서가장 빨리 만나는 Docker "},"book/03.-back-end/06.-devops/docker/cli.html":{"url":"book/03.-back-end/06.-devops/docker/cli.html","title":"CLI","keywords":"","body":"CLI Version 버전 확인 (version) $ docker version $ docker --version $ docker version 정보 확인 (info) $ docker info Image 이미지 찾기 (search) Syntax $ docker search IMAGE Example $ docker search ubuntu 이미지 다운 (pull) Syntax $ docker pull IMAGE[:TAG] Example $ docker pull ubuntu:latest 이미지 목록 (ls) Syntax $ docker image ls 이미지 삭제 (rmi) Syntax $ docker rmi IMAGE[:TAG] Example $ docker rmi ubuntu Container 컨테이너 생성 (run) Syntax $ docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...] Example $ docker run -i -t -d -p 80:80/tcp --name ubuntu_container ubuntu /bin/bash ubuntu 이미지를 컨테이너로 생성 ubuntu 이미지를 컨테이너로 생성 -i(interactive) 표준 입력(stdin)을 활성화 컨테이너와 연결(attach)되어 있지 않더라도 표준 입력을 유지합니다. 보통 이 옵션을 사용하여 Bash에 명령을 입력합니다. -t(Pseudo-tty) TTY 모드 Bash Shell 사용하려면 필요한 옵션 이 옵션을 설정하지 않으면 명령을 입력할 수는 있지만 셸이 표시되지 않습니다. -d (detached) 데몬 모드 컨테이너가 백그라운드로 동작 된다 -v (volume) 호스트의 디렉토리가 데이터 볼륨으로 생성되어 공유된다. [HOST_PATH] : [CONTAINER_PATH] -p (port) 컨테이너 포트 포워딩 [HOST_PORT] : [CONTAINER_PORT] --name 컨테이너의 이름을 지정 /bin/bash 쉘을 이용하여 입출력을 할 수 있다. 컨테이너 목록 (ls) $ docker container ls [option] # running $ docker container ls --all # all $ docker container ls -aq # all and quite mode 컨테이너 기동 (start) $ docker start CONTAINER 컨테이너 재시작 (restart) $ docker restart CONTAINER 컨테이너 접속 (attach) $ docker attach CONTAINER 컨테이너 내부 명령 실행 (exec) $ docker exec CONTAINER COMMAND [ARG...] Docker 를 컨테이너로 진입 후 exit 명령어로 컨테이너를 빠져 나오면 컨테이너가 종료되기 때문에 이에 대해 사용한다. $ docker exec -it CONTAINER /bin/bash CONTAINER 이름을 가진 컨테이너에 /bin/bash 쉘을 사용한다.exit 명령어로 Shell (컨테이너) 을 빠져 나와도 컨테이너가 종료되지 않는다. 컨테이너 삭제 (rm) $ docker rm CONTAINER 컨테이너 세부정보 확인 (inspect) 컨테이너의 세부정보를 json 형태로 확인 가능 $ docker inspect CONTAINER 컨테이너에 파일 복사 (cp) 컨테이너 -> 호스트 $ docker cp CONTAINER:CONTAINER_FILE_PATH HOST_FILE_PATH 호스트 -> 컨테이너 $ docker cp HOST_FILE_PATH CONTAINER:CONTAINER_FILE_PATH $ docker cp ubuntu:/etc/nginx/nginx.conf ./ ubuntu 내에 있는 nginx.conf 파일을 지정된 로컬 호스트 경로로 복사한다. "},"book/03.-back-end/06.-devops/kubernetes.html":{"url":"book/03.-back-end/06.-devops/kubernetes.html","title":"Kubernetes","keywords":"","body":"Kubernetes docker-swarm, mara 참고자료 https://www.popit.kr/kubernetes-introduction/ "},"book/03.-back-end/06.-devops/git.html":{"url":"book/03.-back-end/06.-devops/git.html","title":"Git","keywords":"","body":"Git SSH 키 만들기 ssh-keygen $ ssh-keygen -t rsa -b 4096 -C \"rrest@icloud.com\" Generating public/private rsa key pair. Enter file in which to save the key (/Users/rrest/.ssh/id_rsa): /Users/rrest/.ssh/id_rsa already exists. Overwrite (y/n)? y Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /Users/rrest/.ssh/id_rsa. Your public key has been saved in /Users/rrest/.ssh/id_rsa.pub. The key fingerprint is: SHA256:1iaYasPL6u/8cJY06MnhX7Z2J45cr4nz673wT8cnI20 rrest@icloud.com The key's randomart image is: +---[RSA 4096]----+ | | | | | | | . o . | | o = S o | | = = + o . . | | @ + o o . E +| | + B +o=o*.+ +.| | .o+*.o.=*B==o. | +----[SHA256]-----+ ~/.ssh 경로에 다음 파일이 생성된다. id_rsa 개인키 (지정 경로 ~/.ssh 에 보관) id_rsa.pub 공개키 (복사해서 저장소에 넣음) Parameters -t 암호화 타입 -b 생성할 키의 비트수 (default: 2048) -C 주석입력 리버트 (Revert) Syntax $ git revert {COMMIT_NUMBER} CLI 로컬 브랜치 생성 & 체크아웃 현재 브랜치 기준으로 생성된다. $ git checkout -b feature/CNST-001 로컬 상태 보기 (변경 파일) $ git status 로컬 작업 Staged files 로 올리기 $ git add file1 file2 file3 (...) $ git add . $ git add * 로컬 작업 Unstaged files 로 내리기 $ git reset file1 file2 file3 (...) $ git reset * $ git reset . 로컬 작업 되돌리기 Unstaged files 로 들어 있어야 함 $ git checkout file1 $ git checkout * 작업 커밋하기 $ git commit -m '작업내역' 작업 푸시히기 $ git push 원격 브랜치 업데이트 새로 생성된 브랜치 정보를 가져온다. $ git remote update 원격 브랜치 정보 리스트 $ git branch -r 원격 브랜치 다운로드 & 체크아웃 원격 브랜치랑 동잃한 이름으로 체크아웃 한다. $ git checkout -t origin/feature/CNST-001 $ git checkout --track origin/feature/CNST-001 머지 되돌리기 (Merge Commit Revert) 머지 커밋 (Merge Commit) 일반적인 리버트로는 불가능 하다. -m 1 옵션을 넣어 줘야 한다. $ git revert -m 1 {COMMIT_NUMBER} 참고자료 https://mylko72.gitbooks.io/git/content/remote/branch.html SSH 등록 후 원격 저정소 푸시 비밀번호 물어볼때 아래와 같이 키체인에 추가한다. $ ssh-add -K ~/.ssh/id_rsa "},"book/03.-back-end/07.-big-data.html":{"url":"book/03.-back-end/07.-big-data.html","title":"07. Big Data","keywords":"","body":"07. Big Data 시스템 구성도 데이터처리 패키지 비교 Feature Strom Spark Samza Delivery Semantics At Least Once Exactly-Once with Trident Exactly Once Except in some failure scenarios At Least Once State Management Stateless Roll your own or use Trident Stateful Writes state to storage (HDFS) Stateful Embeded key-value store Latency Sub-Second Seconds Depending on batch size Sub-Second Language Support Any JVM-languages, Ruby, Python, Javascript, Perl Scala, JAVA, Python, R Scala, JAVA JVM-languages only Processing Model one-at-a-time micro-batch / batch one-at-a-time Backpressure O O X Stream Source Spouts Receivers ConSumers Stream Primitive Tuple Dstream Message Stream Computation Bolts Transformations Window operations Tasks 결론 Spark는 Latency 에서 다소 느린 점이 있지만, exactly-once 전송을 제공하고 다양한 워크로드 컴포넌트를 제공한다. Storm은 Latency 에서 유리하지만, Trident를 적용해야 exactly-once 전송을 제공하며 상태관리기능도 Trident를 통해서 적용하거나 자체개발을 해야 한다. Samza는 Latency 에서 유리하지만, 아직 마이너버전이고 At Least Once 전송만을 제공하고 있다. 검색 패키지 비교 Feature Solr Elastic Search Community & Developers Apache Software Foundation and community support Single commercial entity and its employees Node Discovery Apache Zookeeper, mature and battle-tested in a large number of projects Zen, built into Elasticsearch itself, requires dedicated master nodes to be split brain proof Shard Placement Static in nature, requires manual work to migrate shards, starting from Solr 7 – Autoscaling API allows for some dynamic actions Dynamic, shards can be moved on demand depending on the cluster state Caches Global, invalidated with each segment change Per segment, better for dynamically changing data Analytics Engine Facets and powerful streaming aggregations Sophisticated and highly flexible aggregations Optimized Query Execution Currently none Faster range queries depending on the context Search Speed Best for static data, because of caches and uninverted reader Very good for rapidly changing data, because of per-segment caches Analysis Engine Performance Great for static data with exact calculations Exactness of the results depends on data placement Full Text Search Features Language analysis based on Lucene, multiple suggesters, spell checkers, rich highlighting support Language analysis based on Lucene, single suggest API implementation, highlighting rescoring DevOps Friendliness Not fully there yet, but coming Very good APIs Non-flat Data Handling Nested documents and parent-child support Natural support with nested and object types allowing for virtually endless nesting and parent-child support Query DSL JSON (limited), XML (limited) or URL parameters JSON Index/Collection Leader Control Leader placement control and leader rebalancing possibility to even the load on the nodes Not possible Join Currently none Parent_type/Children_type Machine Learning Built-in – on top of streaming aggregations focused on logistic regression and learning to rank contrib module Commercial feature, focused on anomalies and outliers and time-series data Ecosystem Modest – Banana, Zeppelin with community support Rich – Kibana, Grafana, with large entities support and big user base RDBMS Ingestion dataimportHandler logstash 데이터 수집 패키지 비교 Feature Flume Fluentd Log Stash Sqoop 언어 Java Ruby Ruby & Java Java 입력 Avro Source Dummy Input Beats Input FTP Connector Exec Source Exec Input Elastic Search Input Hbase Connector HTTP Source Forward Input Exec Input HDFS Connector JMS Source HTTP Input File Input JDBC Connector Kafka Source Monitor Agent Input HTTP Input Kafka Connector NetCat TCP Source Syslog Input IRC Input Kite Connector NetCat UDP Source Tail Input JDBC Input Scribe Source TCP Input JMS Input Sequence Generator Source UDP Input Kafka Input Spooling Directory Source Windows Eventlog Input Log4J Input Stress Source Source Pipe Input Syslog Source Rabbit MQ Input Taildir Source Redis Input Thrift Source S3 Input Twitter 1% firehose Source Stdin Input STOMP Input Syslog Input TCP Input UDP Input XMPP Input 출력 Avro Sink Copy Output CSV Output Accumulo Connector Elastic Search Sink Elastic Search Output Elastic Search Output FTP Connector File Roll Sink Exec Filter Output Email Output HBase Connector HBase Sink Exec Output Exec Output HDFS Connector HDFS Sink File Output File Output HIVE Connector Hive Sink Forward Output HTTP Output JDBC Connector HTTP Sink Mongo Output InfluxDB Output Kafka Connector IRC Sink Mongo Replset Output IRC Output Kate Connector Kafka Sink Null Option Kafka Output Kite Dataset Sink Relabel Ouput Mongo DB Output Logger Sink Rewrite Tag Filter Output Nagios Output MorphlineSolr Sink Round Robin Output Open TSDB Output Null Sink S3 Output Pipi Output Thrift Sink Stdout Output Rabbit MQ Output WebHDFS Output Redis Output S3 Output Solr Http Output Stdout Output STOMP Output Syslog Output TCP Output UDP Output Web HDFS Output XMPP Output 버퍼 Memory Channel Memory Buffer Memory Queue JDBC Channel File Buffer Presistent Queue Kafka Channel File Channel Spillable Memory Channel Pseudo Transaction Channel 구성 Single Multi-Agent Flow Consolidation Multiplexing 메세지 전송 패키지 비교 Feature Kafka Rabbit MQ 클라이언트 C / C++ Clojure Python Erlang Go (AKA golang) Haskell Erlang Perl .Net Scala Clojure Java Ruby Python Node JS Ruby Proxy (HTTP REST, etc) PHP Perl Swift Stdin / Stdout .Net (C#) PHP Objective-C Rust JS Alternative Java Go Storm Elixir Scala DSL Swift 기본 메시징 처리 방식 Topic 방식 (발행 - 구독) Queue 방식 (발생 - 소비) Consumer Group 설정해서 Queue 방식 사용 MQTT 를 통해서 Topic 방식 사용 클라이언트 동작 Client Pull Server Push 지원 프로토콜 TCP AMQP MQTT STOMP 저장소 파일 메모리 / 파일 결론 Kafka는 IO 방식과 프로토콜의 오버 헤드가 적어 스트리밍 형태의 데이터 전송에 적합 Rabbbit MQ는 표준 프로토콜을 제공하고 큐에 데이터가 유입되면 이벤트가 발행해서 클라이언트에 데이터를 전달하는 이벤트 처리에 적합 하다. "}}